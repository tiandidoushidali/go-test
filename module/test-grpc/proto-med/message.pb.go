// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: med-common/app/service/med-xim/api/grpc/message.proto

package xim

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	entity "go-test/module/test-grpc/proto-med/im/entity"
	misc "go-test/module/test-grpc/proto-med/im/entity/misc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UnreadReq struct {
	MapId                string   `protobuf:"bytes,1,opt,name=mapId,proto3" json:"mapId,omitempty" form:"mapId"`
	UserId               uint32   `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadReq) Reset()         { *m = UnreadReq{} }
func (m *UnreadReq) String() string { return proto.CompactTextString(m) }
func (*UnreadReq) ProtoMessage()    {}
func (*UnreadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{0}
}
func (m *UnreadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadReq.Merge(m, src)
}
func (m *UnreadReq) XXX_Size() int {
	return m.Size()
}
func (m *UnreadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadReq proto.InternalMessageInfo

func (m *UnreadReq) GetMapId() string {
	if m != nil {
		return m.MapId
	}
	return ""
}

func (m *UnreadReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UnreadResp struct {
	UnreadMap            map[string]uint32 `protobuf:"bytes,1,rep,name=unreadMap,proto3" json:"unreadMap" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *UnreadResp) Reset()         { *m = UnreadResp{} }
func (m *UnreadResp) String() string { return proto.CompactTextString(m) }
func (*UnreadResp) ProtoMessage()    {}
func (*UnreadResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{1}
}
func (m *UnreadResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadResp.Merge(m, src)
}
func (m *UnreadResp) XXX_Size() int {
	return m.Size()
}
func (m *UnreadResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadResp proto.InternalMessageInfo

func (m *UnreadResp) GetUnreadMap() map[string]uint32 {
	if m != nil {
		return m.UnreadMap
	}
	return nil
}

type UnreadAllReq struct {
	UserId               uint32   `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadAllReq) Reset()         { *m = UnreadAllReq{} }
func (m *UnreadAllReq) String() string { return proto.CompactTextString(m) }
func (*UnreadAllReq) ProtoMessage()    {}
func (*UnreadAllReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{2}
}
func (m *UnreadAllReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadAllReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadAllReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadAllReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadAllReq.Merge(m, src)
}
func (m *UnreadAllReq) XXX_Size() int {
	return m.Size()
}
func (m *UnreadAllReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadAllReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadAllReq proto.InternalMessageInfo

func (m *UnreadAllReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UnreadAllResp struct {
	UnreadAllMap         map[string]uint32 `protobuf:"bytes,1,rep,name=unreadAllMap,proto3" json:"unreadAllMap" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *UnreadAllResp) Reset()         { *m = UnreadAllResp{} }
func (m *UnreadAllResp) String() string { return proto.CompactTextString(m) }
func (*UnreadAllResp) ProtoMessage()    {}
func (*UnreadAllResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{3}
}
func (m *UnreadAllResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadAllResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadAllResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadAllResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadAllResp.Merge(m, src)
}
func (m *UnreadAllResp) XXX_Size() int {
	return m.Size()
}
func (m *UnreadAllResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadAllResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadAllResp proto.InternalMessageInfo

func (m *UnreadAllResp) GetUnreadAllMap() map[string]uint32 {
	if m != nil {
		return m.UnreadAllMap
	}
	return nil
}

type UnreadBatchReq struct {
	ReqStr               string   `protobuf:"bytes,1,opt,name=reqStr,proto3" json:"reqStr,omitempty" form:"reqStr"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadBatchReq) Reset()         { *m = UnreadBatchReq{} }
func (m *UnreadBatchReq) String() string { return proto.CompactTextString(m) }
func (*UnreadBatchReq) ProtoMessage()    {}
func (*UnreadBatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{4}
}
func (m *UnreadBatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadBatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadBatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadBatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadBatchReq.Merge(m, src)
}
func (m *UnreadBatchReq) XXX_Size() int {
	return m.Size()
}
func (m *UnreadBatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadBatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadBatchReq proto.InternalMessageInfo

func (m *UnreadBatchReq) GetReqStr() string {
	if m != nil {
		return m.ReqStr
	}
	return ""
}

type UnreadBatchResp struct {
	UnreadBatchList      []*UnreadBatch `protobuf:"bytes,1,rep,name=unreadBatchList,proto3" json:"unreadBatchList"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UnreadBatchResp) Reset()         { *m = UnreadBatchResp{} }
func (m *UnreadBatchResp) String() string { return proto.CompactTextString(m) }
func (*UnreadBatchResp) ProtoMessage()    {}
func (*UnreadBatchResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{5}
}
func (m *UnreadBatchResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadBatchResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadBatchResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadBatchResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadBatchResp.Merge(m, src)
}
func (m *UnreadBatchResp) XXX_Size() int {
	return m.Size()
}
func (m *UnreadBatchResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadBatchResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadBatchResp proto.InternalMessageInfo

func (m *UnreadBatchResp) GetUnreadBatchList() []*UnreadBatch {
	if m != nil {
		return m.UnreadBatchList
	}
	return nil
}

type UnreadBatch struct {
	UserId               uint32   `protobuf:"varint,1,opt,name=userId,proto3" json:"user_id"`
	MapId                string   `protobuf:"bytes,2,opt,name=mapId,proto3" json:"map_id"`
	Count                uint32   `protobuf:"varint,3,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadBatch) Reset()         { *m = UnreadBatch{} }
func (m *UnreadBatch) String() string { return proto.CompactTextString(m) }
func (*UnreadBatch) ProtoMessage()    {}
func (*UnreadBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{6}
}
func (m *UnreadBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadBatch.Merge(m, src)
}
func (m *UnreadBatch) XXX_Size() int {
	return m.Size()
}
func (m *UnreadBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadBatch.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadBatch proto.InternalMessageInfo

func (m *UnreadBatch) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UnreadBatch) GetMapId() string {
	if m != nil {
		return m.MapId
	}
	return ""
}

func (m *UnreadBatch) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type MarkLatestMsgReadReq struct {
	UserId               uint32   `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	MapId                string   `protobuf:"bytes,2,opt,name=mapId,proto3" json:"mapId,omitempty" form:"mapId"`
	MsgId                string   `protobuf:"bytes,3,opt,name=msgId,proto3" json:"msgId,omitempty" form:"msgId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkLatestMsgReadReq) Reset()         { *m = MarkLatestMsgReadReq{} }
func (m *MarkLatestMsgReadReq) String() string { return proto.CompactTextString(m) }
func (*MarkLatestMsgReadReq) ProtoMessage()    {}
func (*MarkLatestMsgReadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{7}
}
func (m *MarkLatestMsgReadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkLatestMsgReadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkLatestMsgReadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkLatestMsgReadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkLatestMsgReadReq.Merge(m, src)
}
func (m *MarkLatestMsgReadReq) XXX_Size() int {
	return m.Size()
}
func (m *MarkLatestMsgReadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkLatestMsgReadReq.DiscardUnknown(m)
}

var xxx_messageInfo_MarkLatestMsgReadReq proto.InternalMessageInfo

func (m *MarkLatestMsgReadReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MarkLatestMsgReadReq) GetMapId() string {
	if m != nil {
		return m.MapId
	}
	return ""
}

func (m *MarkLatestMsgReadReq) GetMsgId() string {
	if m != nil {
		return m.MsgId
	}
	return ""
}

type MarkLatestMsgReadResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkLatestMsgReadResp) Reset()         { *m = MarkLatestMsgReadResp{} }
func (m *MarkLatestMsgReadResp) String() string { return proto.CompactTextString(m) }
func (*MarkLatestMsgReadResp) ProtoMessage()    {}
func (*MarkLatestMsgReadResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{8}
}
func (m *MarkLatestMsgReadResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkLatestMsgReadResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkLatestMsgReadResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkLatestMsgReadResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkLatestMsgReadResp.Merge(m, src)
}
func (m *MarkLatestMsgReadResp) XXX_Size() int {
	return m.Size()
}
func (m *MarkLatestMsgReadResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkLatestMsgReadResp.DiscardUnknown(m)
}

var xxx_messageInfo_MarkLatestMsgReadResp proto.InternalMessageInfo

type UnreadSweepV2Req struct {
	MapId                string   `protobuf:"bytes,1,opt,name=mapId,proto3" json:"mapId,omitempty" form:"map_id"`
	UserId               uint32   `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	SingleId             uint32   `protobuf:"varint,3,opt,name=singleId,proto3" json:"singleId,omitempty" form:"singleId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadSweepV2Req) Reset()         { *m = UnreadSweepV2Req{} }
func (m *UnreadSweepV2Req) String() string { return proto.CompactTextString(m) }
func (*UnreadSweepV2Req) ProtoMessage()    {}
func (*UnreadSweepV2Req) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{9}
}
func (m *UnreadSweepV2Req) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadSweepV2Req) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadSweepV2Req.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadSweepV2Req) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadSweepV2Req.Merge(m, src)
}
func (m *UnreadSweepV2Req) XXX_Size() int {
	return m.Size()
}
func (m *UnreadSweepV2Req) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadSweepV2Req.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadSweepV2Req proto.InternalMessageInfo

func (m *UnreadSweepV2Req) GetMapId() string {
	if m != nil {
		return m.MapId
	}
	return ""
}

func (m *UnreadSweepV2Req) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UnreadSweepV2Req) GetSingleId() uint32 {
	if m != nil {
		return m.SingleId
	}
	return 0
}

type UnreadSweepV2Resp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadSweepV2Resp) Reset()         { *m = UnreadSweepV2Resp{} }
func (m *UnreadSweepV2Resp) String() string { return proto.CompactTextString(m) }
func (*UnreadSweepV2Resp) ProtoMessage()    {}
func (*UnreadSweepV2Resp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{10}
}
func (m *UnreadSweepV2Resp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadSweepV2Resp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadSweepV2Resp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadSweepV2Resp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadSweepV2Resp.Merge(m, src)
}
func (m *UnreadSweepV2Resp) XXX_Size() int {
	return m.Size()
}
func (m *UnreadSweepV2Resp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadSweepV2Resp.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadSweepV2Resp proto.InternalMessageInfo

type UnreadCountReq struct {
	MapIds               string   `protobuf:"bytes,1,opt,name=mapIds,proto3" json:"mapIds,omitempty" form:"map_ids"`
	UserId               uint32   `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadCountReq) Reset()         { *m = UnreadCountReq{} }
func (m *UnreadCountReq) String() string { return proto.CompactTextString(m) }
func (*UnreadCountReq) ProtoMessage()    {}
func (*UnreadCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{11}
}
func (m *UnreadCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadCountReq.Merge(m, src)
}
func (m *UnreadCountReq) XXX_Size() int {
	return m.Size()
}
func (m *UnreadCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadCountReq proto.InternalMessageInfo

func (m *UnreadCountReq) GetMapIds() string {
	if m != nil {
		return m.MapIds
	}
	return ""
}

func (m *UnreadCountReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UnreadCountResp struct {
	UnreadCountMap       map[string]uint32 `protobuf:"bytes,1,rep,name=unreadCountMap,proto3" json:"unreadCountMap" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *UnreadCountResp) Reset()         { *m = UnreadCountResp{} }
func (m *UnreadCountResp) String() string { return proto.CompactTextString(m) }
func (*UnreadCountResp) ProtoMessage()    {}
func (*UnreadCountResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{12}
}
func (m *UnreadCountResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadCountResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadCountResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadCountResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadCountResp.Merge(m, src)
}
func (m *UnreadCountResp) XXX_Size() int {
	return m.Size()
}
func (m *UnreadCountResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadCountResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadCountResp proto.InternalMessageInfo

func (m *UnreadCountResp) GetUnreadCountMap() map[string]uint32 {
	if m != nil {
		return m.UnreadCountMap
	}
	return nil
}

type ReadMarkReq struct {
	MapId                int64    `protobuf:"varint,1,opt,name=mapId,proto3" json:"map_id" form:"map_id"`
	MsgId                int64    `protobuf:"varint,2,opt,name=msgId,proto3" json:"msg_id" form:"msg_id"`
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty" form:"type"`
	UserId               uint32   `protobuf:"varint,4,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadMarkReq) Reset()         { *m = ReadMarkReq{} }
func (m *ReadMarkReq) String() string { return proto.CompactTextString(m) }
func (*ReadMarkReq) ProtoMessage()    {}
func (*ReadMarkReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{13}
}
func (m *ReadMarkReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadMarkReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadMarkReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadMarkReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadMarkReq.Merge(m, src)
}
func (m *ReadMarkReq) XXX_Size() int {
	return m.Size()
}
func (m *ReadMarkReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadMarkReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReadMarkReq proto.InternalMessageInfo

func (m *ReadMarkReq) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (m *ReadMarkReq) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReadMarkReq) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ReadMarkReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type ReadMarkResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadMarkResp) Reset()         { *m = ReadMarkResp{} }
func (m *ReadMarkResp) String() string { return proto.CompactTextString(m) }
func (*ReadMarkResp) ProtoMessage()    {}
func (*ReadMarkResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{14}
}
func (m *ReadMarkResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadMarkResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadMarkResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadMarkResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadMarkResp.Merge(m, src)
}
func (m *ReadMarkResp) XXX_Size() int {
	return m.Size()
}
func (m *ReadMarkResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadMarkResp.DiscardUnknown(m)
}

var xxx_messageInfo_ReadMarkResp proto.InternalMessageInfo

type UnreadInfoReq struct {
	MapId                string   `protobuf:"bytes,1,opt,name=mapId,proto3" json:"mapId,omitempty" form:"map_id"`
	UserId               uint32   `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadInfoReq) Reset()         { *m = UnreadInfoReq{} }
func (m *UnreadInfoReq) String() string { return proto.CompactTextString(m) }
func (*UnreadInfoReq) ProtoMessage()    {}
func (*UnreadInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{15}
}
func (m *UnreadInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadInfoReq.Merge(m, src)
}
func (m *UnreadInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *UnreadInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadInfoReq proto.InternalMessageInfo

func (m *UnreadInfoReq) GetMapId() string {
	if m != nil {
		return m.MapId
	}
	return ""
}

func (m *UnreadInfoReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UnreadInfoResp struct {
	UnreadInfoMap        map[uint32]*UnreadMark `protobuf:"bytes,1,rep,name=unreadInfoMap,proto3" json:"unreadInfoMap" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UnreadInfoResp) Reset()         { *m = UnreadInfoResp{} }
func (m *UnreadInfoResp) String() string { return proto.CompactTextString(m) }
func (*UnreadInfoResp) ProtoMessage()    {}
func (*UnreadInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{16}
}
func (m *UnreadInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadInfoResp.Merge(m, src)
}
func (m *UnreadInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *UnreadInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadInfoResp proto.InternalMessageInfo

func (m *UnreadInfoResp) GetUnreadInfoMap() map[uint32]*UnreadMark {
	if m != nil {
		return m.UnreadInfoMap
	}
	return nil
}

type UnreadMark struct {
	GroupId              uint32   `protobuf:"varint,1,opt,name=groupId,proto3" json:"group_id"`
	MsgId                string   `protobuf:"bytes,2,opt,name=msgId,proto3" json:"msg_id"`
	UserId               uint32   `protobuf:"varint,3,opt,name=userId,proto3" json:"user_id"`
	UserPlatform         string   `protobuf:"bytes,4,opt,name=userPlatform,proto3" json:"user_platform"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadMark) Reset()         { *m = UnreadMark{} }
func (m *UnreadMark) String() string { return proto.CompactTextString(m) }
func (*UnreadMark) ProtoMessage()    {}
func (*UnreadMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{17}
}
func (m *UnreadMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadMark.Merge(m, src)
}
func (m *UnreadMark) XXX_Size() int {
	return m.Size()
}
func (m *UnreadMark) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadMark.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadMark proto.InternalMessageInfo

func (m *UnreadMark) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UnreadMark) GetMsgId() string {
	if m != nil {
		return m.MsgId
	}
	return ""
}

func (m *UnreadMark) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UnreadMark) GetUserPlatform() string {
	if m != nil {
		return m.UserPlatform
	}
	return ""
}

type UnreadSweepReq struct {
	//uid
	Uid int64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid"`
	//群组id
	GroupId              string   `protobuf:"bytes,2,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadSweepReq) Reset()         { *m = UnreadSweepReq{} }
func (m *UnreadSweepReq) String() string { return proto.CompactTextString(m) }
func (*UnreadSweepReq) ProtoMessage()    {}
func (*UnreadSweepReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{18}
}
func (m *UnreadSweepReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadSweepReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadSweepReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadSweepReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadSweepReq.Merge(m, src)
}
func (m *UnreadSweepReq) XXX_Size() int {
	return m.Size()
}
func (m *UnreadSweepReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadSweepReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadSweepReq proto.InternalMessageInfo

func (m *UnreadSweepReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UnreadSweepReq) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

type UnreadSweepResp struct {
	//清空状态
	Status               int32    `protobuf:"varint,1,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadSweepResp) Reset()         { *m = UnreadSweepResp{} }
func (m *UnreadSweepResp) String() string { return proto.CompactTextString(m) }
func (*UnreadSweepResp) ProtoMessage()    {}
func (*UnreadSweepResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{19}
}
func (m *UnreadSweepResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadSweepResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadSweepResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadSweepResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadSweepResp.Merge(m, src)
}
func (m *UnreadSweepResp) XXX_Size() int {
	return m.Size()
}
func (m *UnreadSweepResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadSweepResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadSweepResp proto.InternalMessageInfo

func (m *UnreadSweepResp) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type UnreadPointReq struct {
	//uid
	Uid int64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid"`
	//群组列表
	MapIds               []string `protobuf:"bytes,2,rep,name=mapIds,proto3" json:"mapIds,omitempty" form:"mapIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnreadPointReq) Reset()         { *m = UnreadPointReq{} }
func (m *UnreadPointReq) String() string { return proto.CompactTextString(m) }
func (*UnreadPointReq) ProtoMessage()    {}
func (*UnreadPointReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{20}
}
func (m *UnreadPointReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadPointReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadPointReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadPointReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadPointReq.Merge(m, src)
}
func (m *UnreadPointReq) XXX_Size() int {
	return m.Size()
}
func (m *UnreadPointReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadPointReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadPointReq proto.InternalMessageInfo

func (m *UnreadPointReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UnreadPointReq) GetMapIds() []string {
	if m != nil {
		return m.MapIds
	}
	return nil
}

type UnreadPointResp struct {
	//未读数量
	RetMap               map[string]int32 `protobuf:"bytes,1,rep,name=retMap,proto3" json:"retMap" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UnreadPointResp) Reset()         { *m = UnreadPointResp{} }
func (m *UnreadPointResp) String() string { return proto.CompactTextString(m) }
func (*UnreadPointResp) ProtoMessage()    {}
func (*UnreadPointResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{21}
}
func (m *UnreadPointResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnreadPointResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnreadPointResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnreadPointResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnreadPointResp.Merge(m, src)
}
func (m *UnreadPointResp) XXX_Size() int {
	return m.Size()
}
func (m *UnreadPointResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnreadPointResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnreadPointResp proto.InternalMessageInfo

func (m *UnreadPointResp) GetRetMap() map[string]int32 {
	if m != nil {
		return m.RetMap
	}
	return nil
}

type AtUserReq struct {
	// 医生ID
	DoctorId int32 `protobuf:"varint,1,opt,name=doctorId,proto3" json:"doctorId,omitempty" form:"doctorId"`
	// 患者ID
	PatientId int32 `protobuf:"varint,2,opt,name=patientId,proto3" json:"patientId,omitempty" form:"patientId"`
	// 批量用户ID 医生ids/患者ids
	AtUserIds []int32 `protobuf:"varint,3,rep,packed,name=atUserIds,proto3" json:"atUserIds,omitempty" form:"atUserIds"`
	// groupId
	GroupId              int32    `protobuf:"varint,4,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AtUserReq) Reset()         { *m = AtUserReq{} }
func (m *AtUserReq) String() string { return proto.CompactTextString(m) }
func (*AtUserReq) ProtoMessage()    {}
func (*AtUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{22}
}
func (m *AtUserReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtUserReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtUserReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtUserReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtUserReq.Merge(m, src)
}
func (m *AtUserReq) XXX_Size() int {
	return m.Size()
}
func (m *AtUserReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AtUserReq.DiscardUnknown(m)
}

var xxx_messageInfo_AtUserReq proto.InternalMessageInfo

func (m *AtUserReq) GetDoctorId() int32 {
	if m != nil {
		return m.DoctorId
	}
	return 0
}

func (m *AtUserReq) GetPatientId() int32 {
	if m != nil {
		return m.PatientId
	}
	return 0
}

func (m *AtUserReq) GetAtUserIds() []int32 {
	if m != nil {
		return m.AtUserIds
	}
	return nil
}

func (m *AtUserReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type AtUserResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AtUserResp) Reset()         { *m = AtUserResp{} }
func (m *AtUserResp) String() string { return proto.CompactTextString(m) }
func (*AtUserResp) ProtoMessage()    {}
func (*AtUserResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{23}
}
func (m *AtUserResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtUserResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtUserResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtUserResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtUserResp.Merge(m, src)
}
func (m *AtUserResp) XXX_Size() int {
	return m.Size()
}
func (m *AtUserResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AtUserResp.DiscardUnknown(m)
}

var xxx_messageInfo_AtUserResp proto.InternalMessageInfo

type ReadAtUserReq struct {
	// @用户的ID
	UserId int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	// 列表用户id 医生/患者
	OtherUserId int32 `protobuf:"varint,2,opt,name=otherUserId,proto3" json:"otherUserId,omitempty" form:"otherUserId"`
	// groupId
	GroupId              int32    `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadAtUserReq) Reset()         { *m = ReadAtUserReq{} }
func (m *ReadAtUserReq) String() string { return proto.CompactTextString(m) }
func (*ReadAtUserReq) ProtoMessage()    {}
func (*ReadAtUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{24}
}
func (m *ReadAtUserReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadAtUserReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadAtUserReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadAtUserReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadAtUserReq.Merge(m, src)
}
func (m *ReadAtUserReq) XXX_Size() int {
	return m.Size()
}
func (m *ReadAtUserReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadAtUserReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReadAtUserReq proto.InternalMessageInfo

func (m *ReadAtUserReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReadAtUserReq) GetOtherUserId() int32 {
	if m != nil {
		return m.OtherUserId
	}
	return 0
}

func (m *ReadAtUserReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type ReadAtUserResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadAtUserResp) Reset()         { *m = ReadAtUserResp{} }
func (m *ReadAtUserResp) String() string { return proto.CompactTextString(m) }
func (*ReadAtUserResp) ProtoMessage()    {}
func (*ReadAtUserResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{25}
}
func (m *ReadAtUserResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadAtUserResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadAtUserResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadAtUserResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadAtUserResp.Merge(m, src)
}
func (m *ReadAtUserResp) XXX_Size() int {
	return m.Size()
}
func (m *ReadAtUserResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadAtUserResp.DiscardUnknown(m)
}

var xxx_messageInfo_ReadAtUserResp proto.InternalMessageInfo

type FetchMessageAtUserReq struct {
	// userID
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid"`
	// 批量用户ID 医生ids/患者ids
	OtherUserIds         []int32  `protobuf:"varint,2,rep,packed,name=otherUserIds,proto3" json:"otherUserIds,omitempty" form:"otherUserIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchMessageAtUserReq) Reset()         { *m = FetchMessageAtUserReq{} }
func (m *FetchMessageAtUserReq) String() string { return proto.CompactTextString(m) }
func (*FetchMessageAtUserReq) ProtoMessage()    {}
func (*FetchMessageAtUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{26}
}
func (m *FetchMessageAtUserReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMessageAtUserReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMessageAtUserReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMessageAtUserReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMessageAtUserReq.Merge(m, src)
}
func (m *FetchMessageAtUserReq) XXX_Size() int {
	return m.Size()
}
func (m *FetchMessageAtUserReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMessageAtUserReq.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMessageAtUserReq proto.InternalMessageInfo

func (m *FetchMessageAtUserReq) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *FetchMessageAtUserReq) GetOtherUserIds() []int32 {
	if m != nil {
		return m.OtherUserIds
	}
	return nil
}

type FetchMessageAtUserResp struct {
	RetMap               map[int32]int32 `protobuf:"bytes,1,rep,name=retMap,proto3" json:"retMap" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FetchMessageAtUserResp) Reset()         { *m = FetchMessageAtUserResp{} }
func (m *FetchMessageAtUserResp) String() string { return proto.CompactTextString(m) }
func (*FetchMessageAtUserResp) ProtoMessage()    {}
func (*FetchMessageAtUserResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{27}
}
func (m *FetchMessageAtUserResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMessageAtUserResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMessageAtUserResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMessageAtUserResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMessageAtUserResp.Merge(m, src)
}
func (m *FetchMessageAtUserResp) XXX_Size() int {
	return m.Size()
}
func (m *FetchMessageAtUserResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMessageAtUserResp.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMessageAtUserResp proto.InternalMessageInfo

func (m *FetchMessageAtUserResp) GetRetMap() map[int32]int32 {
	if m != nil {
		return m.RetMap
	}
	return nil
}

type MarkMessageUnReadReq struct {
	// 医助ID deprecated
	AssistantId int64 `protobuf:"varint,1,opt,name=assistantId,proto3" json:"assistantId,omitempty" form:"assistantId"`
	// 健管师ID deprecated
	HealthmanIds []int64 `protobuf:"varint,2,rep,packed,name=healthmanIds,proto3" json:"healthmanIds,omitempty" form:"healthmanIds"`
	// 医生ID
	DoctorId int64 `protobuf:"varint,3,opt,name=doctorId,proto3" json:"doctorId,omitempty" form:"doctorId"`
	// 患者ID
	PatientId int64 `protobuf:"varint,4,opt,name=patientId,proto3" json:"patientId,omitempty" form:"patientId"`
	// 诊室ID
	GroupId int64 `protobuf:"varint,5,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	// 消息ID
	MessageId int64 `protobuf:"varint,6,opt,name=messageId,proto3" json:"messageId,omitempty" form:"messageId"`
	// 发送消息用户
	FromUserId int64 `protobuf:"varint,7,opt,name=fromUserId,proto3" json:"fromUserId,omitempty" form:"fromUserId"`
	// 发送消息用户角色
	FromUserRole string `protobuf:"bytes,8,opt,name=fromUserRole,proto3" json:"fromUserRole,omitempty" form:"fromUserRole"`
	// 辅助角色ID
	OtherUserIds         []int64  `protobuf:"varint,9,rep,packed,name=otherUserIds,proto3" json:"otherUserIds,omitempty" form:"otherUserIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkMessageUnReadReq) Reset()         { *m = MarkMessageUnReadReq{} }
func (m *MarkMessageUnReadReq) String() string { return proto.CompactTextString(m) }
func (*MarkMessageUnReadReq) ProtoMessage()    {}
func (*MarkMessageUnReadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{28}
}
func (m *MarkMessageUnReadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkMessageUnReadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkMessageUnReadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkMessageUnReadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkMessageUnReadReq.Merge(m, src)
}
func (m *MarkMessageUnReadReq) XXX_Size() int {
	return m.Size()
}
func (m *MarkMessageUnReadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkMessageUnReadReq.DiscardUnknown(m)
}

var xxx_messageInfo_MarkMessageUnReadReq proto.InternalMessageInfo

func (m *MarkMessageUnReadReq) GetAssistantId() int64 {
	if m != nil {
		return m.AssistantId
	}
	return 0
}

func (m *MarkMessageUnReadReq) GetHealthmanIds() []int64 {
	if m != nil {
		return m.HealthmanIds
	}
	return nil
}

func (m *MarkMessageUnReadReq) GetDoctorId() int64 {
	if m != nil {
		return m.DoctorId
	}
	return 0
}

func (m *MarkMessageUnReadReq) GetPatientId() int64 {
	if m != nil {
		return m.PatientId
	}
	return 0
}

func (m *MarkMessageUnReadReq) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *MarkMessageUnReadReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *MarkMessageUnReadReq) GetFromUserId() int64 {
	if m != nil {
		return m.FromUserId
	}
	return 0
}

func (m *MarkMessageUnReadReq) GetFromUserRole() string {
	if m != nil {
		return m.FromUserRole
	}
	return ""
}

func (m *MarkMessageUnReadReq) GetOtherUserIds() []int64 {
	if m != nil {
		return m.OtherUserIds
	}
	return nil
}

type MarkMessageUnReadResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkMessageUnReadResp) Reset()         { *m = MarkMessageUnReadResp{} }
func (m *MarkMessageUnReadResp) String() string { return proto.CompactTextString(m) }
func (*MarkMessageUnReadResp) ProtoMessage()    {}
func (*MarkMessageUnReadResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{29}
}
func (m *MarkMessageUnReadResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkMessageUnReadResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkMessageUnReadResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkMessageUnReadResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkMessageUnReadResp.Merge(m, src)
}
func (m *MarkMessageUnReadResp) XXX_Size() int {
	return m.Size()
}
func (m *MarkMessageUnReadResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkMessageUnReadResp.DiscardUnknown(m)
}

var xxx_messageInfo_MarkMessageUnReadResp proto.InternalMessageInfo

type UnMarkMessageUnReadReq struct {
	// 登录用户id
	UserId int64 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	// 列表用户id 医生/患者
	OtherUserId int64 `protobuf:"varint,2,opt,name=otherUserId,proto3" json:"otherUserId,omitempty" form:"otherUserId"`
	// groupId
	GroupId              int64    `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnMarkMessageUnReadReq) Reset()         { *m = UnMarkMessageUnReadReq{} }
func (m *UnMarkMessageUnReadReq) String() string { return proto.CompactTextString(m) }
func (*UnMarkMessageUnReadReq) ProtoMessage()    {}
func (*UnMarkMessageUnReadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{30}
}
func (m *UnMarkMessageUnReadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnMarkMessageUnReadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnMarkMessageUnReadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnMarkMessageUnReadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnMarkMessageUnReadReq.Merge(m, src)
}
func (m *UnMarkMessageUnReadReq) XXX_Size() int {
	return m.Size()
}
func (m *UnMarkMessageUnReadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnMarkMessageUnReadReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnMarkMessageUnReadReq proto.InternalMessageInfo

func (m *UnMarkMessageUnReadReq) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UnMarkMessageUnReadReq) GetOtherUserId() int64 {
	if m != nil {
		return m.OtherUserId
	}
	return 0
}

func (m *UnMarkMessageUnReadReq) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type UnMarkMessageUnReadResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnMarkMessageUnReadResp) Reset()         { *m = UnMarkMessageUnReadResp{} }
func (m *UnMarkMessageUnReadResp) String() string { return proto.CompactTextString(m) }
func (*UnMarkMessageUnReadResp) ProtoMessage()    {}
func (*UnMarkMessageUnReadResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{31}
}
func (m *UnMarkMessageUnReadResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnMarkMessageUnReadResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnMarkMessageUnReadResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnMarkMessageUnReadResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnMarkMessageUnReadResp.Merge(m, src)
}
func (m *UnMarkMessageUnReadResp) XXX_Size() int {
	return m.Size()
}
func (m *UnMarkMessageUnReadResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnMarkMessageUnReadResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnMarkMessageUnReadResp proto.InternalMessageInfo

type FetchMessageUnReadTotalReq struct {
	// userID
	UserId int64 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	// otherUserId
	OtherUserIds []int64 `protobuf:"varint,2,rep,packed,name=otherUserIds,proto3" json:"otherUserIds,omitempty" form:"otherUserIds"`
	// 诊室ids
	GroupIds             []int64  `protobuf:"varint,3,rep,packed,name=groupIds,proto3" json:"groupIds,omitempty" form:"groupIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchMessageUnReadTotalReq) Reset()         { *m = FetchMessageUnReadTotalReq{} }
func (m *FetchMessageUnReadTotalReq) String() string { return proto.CompactTextString(m) }
func (*FetchMessageUnReadTotalReq) ProtoMessage()    {}
func (*FetchMessageUnReadTotalReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{32}
}
func (m *FetchMessageUnReadTotalReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMessageUnReadTotalReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMessageUnReadTotalReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMessageUnReadTotalReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMessageUnReadTotalReq.Merge(m, src)
}
func (m *FetchMessageUnReadTotalReq) XXX_Size() int {
	return m.Size()
}
func (m *FetchMessageUnReadTotalReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMessageUnReadTotalReq.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMessageUnReadTotalReq proto.InternalMessageInfo

func (m *FetchMessageUnReadTotalReq) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FetchMessageUnReadTotalReq) GetOtherUserIds() []int64 {
	if m != nil {
		return m.OtherUserIds
	}
	return nil
}

func (m *FetchMessageUnReadTotalReq) GetGroupIds() []int64 {
	if m != nil {
		return m.GroupIds
	}
	return nil
}

type FetchMessageUnReadTotalResp struct {
	RetMap               map[int64]*FetchMessageUnReadTotal `protobuf:"bytes,1,rep,name=retMap,proto3" json:"retMap" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *FetchMessageUnReadTotalResp) Reset()         { *m = FetchMessageUnReadTotalResp{} }
func (m *FetchMessageUnReadTotalResp) String() string { return proto.CompactTextString(m) }
func (*FetchMessageUnReadTotalResp) ProtoMessage()    {}
func (*FetchMessageUnReadTotalResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{33}
}
func (m *FetchMessageUnReadTotalResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMessageUnReadTotalResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMessageUnReadTotalResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMessageUnReadTotalResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMessageUnReadTotalResp.Merge(m, src)
}
func (m *FetchMessageUnReadTotalResp) XXX_Size() int {
	return m.Size()
}
func (m *FetchMessageUnReadTotalResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMessageUnReadTotalResp.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMessageUnReadTotalResp proto.InternalMessageInfo

func (m *FetchMessageUnReadTotalResp) GetRetMap() map[int64]*FetchMessageUnReadTotal {
	if m != nil {
		return m.RetMap
	}
	return nil
}

type FetchMessageUnReadTotal struct {
	// 医生消息未读数
	DoctorMsgUnreadTotal int64 `protobuf:"varint,1,opt,name=doctorMsgUnreadTotal,proto3" json:"doctorMsgUnreadTotal"`
	// 患者消息未读数
	PatientMsgUnreadTotal int64 `protobuf:"varint,2,opt,name=patientMsgUnreadTotal,proto3" json:"patientMsgUnreadTotal"`
	// 其他消息未读数（辅助角色）
	AssistantMsgUnreadTotal int64    `protobuf:"varint,3,opt,name=assistantMsgUnreadTotal,proto3" json:"assistantMsgUnreadTotal"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *FetchMessageUnReadTotal) Reset()         { *m = FetchMessageUnReadTotal{} }
func (m *FetchMessageUnReadTotal) String() string { return proto.CompactTextString(m) }
func (*FetchMessageUnReadTotal) ProtoMessage()    {}
func (*FetchMessageUnReadTotal) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{34}
}
func (m *FetchMessageUnReadTotal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMessageUnReadTotal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMessageUnReadTotal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMessageUnReadTotal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMessageUnReadTotal.Merge(m, src)
}
func (m *FetchMessageUnReadTotal) XXX_Size() int {
	return m.Size()
}
func (m *FetchMessageUnReadTotal) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMessageUnReadTotal.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMessageUnReadTotal proto.InternalMessageInfo

func (m *FetchMessageUnReadTotal) GetDoctorMsgUnreadTotal() int64 {
	if m != nil {
		return m.DoctorMsgUnreadTotal
	}
	return 0
}

func (m *FetchMessageUnReadTotal) GetPatientMsgUnreadTotal() int64 {
	if m != nil {
		return m.PatientMsgUnreadTotal
	}
	return 0
}

func (m *FetchMessageUnReadTotal) GetAssistantMsgUnreadTotal() int64 {
	if m != nil {
		return m.AssistantMsgUnreadTotal
	}
	return 0
}

type MarkPrescriptionMessageReq struct {
	// 用户ids
	UserIds []int64 `protobuf:"varint,1,rep,packed,name=userIds,proto3" json:"userIds,omitempty" form:"userIds"`
	// 医生ID
	DoctorId int64 `protobuf:"varint,2,opt,name=doctorId,proto3" json:"doctorId,omitempty" form:"doctorId"`
	// 患者ID
	PatientId int64 `protobuf:"varint,3,opt,name=patientId,proto3" json:"patientId,omitempty" form:"patientId"`
	// groupId
	GroupId int64 `protobuf:"varint,4,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	// 消息ID
	MessageId int64 `protobuf:"varint,5,opt,name=messageId,proto3" json:"messageId,omitempty" form:"messageId"`
	// 发送消息用户
	FromUserId           int64    `protobuf:"varint,6,opt,name=fromUserId,proto3" json:"fromUserId,omitempty" form:"fromUserId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkPrescriptionMessageReq) Reset()         { *m = MarkPrescriptionMessageReq{} }
func (m *MarkPrescriptionMessageReq) String() string { return proto.CompactTextString(m) }
func (*MarkPrescriptionMessageReq) ProtoMessage()    {}
func (*MarkPrescriptionMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{35}
}
func (m *MarkPrescriptionMessageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkPrescriptionMessageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkPrescriptionMessageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkPrescriptionMessageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkPrescriptionMessageReq.Merge(m, src)
}
func (m *MarkPrescriptionMessageReq) XXX_Size() int {
	return m.Size()
}
func (m *MarkPrescriptionMessageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkPrescriptionMessageReq.DiscardUnknown(m)
}

var xxx_messageInfo_MarkPrescriptionMessageReq proto.InternalMessageInfo

func (m *MarkPrescriptionMessageReq) GetUserIds() []int64 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *MarkPrescriptionMessageReq) GetDoctorId() int64 {
	if m != nil {
		return m.DoctorId
	}
	return 0
}

func (m *MarkPrescriptionMessageReq) GetPatientId() int64 {
	if m != nil {
		return m.PatientId
	}
	return 0
}

func (m *MarkPrescriptionMessageReq) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *MarkPrescriptionMessageReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *MarkPrescriptionMessageReq) GetFromUserId() int64 {
	if m != nil {
		return m.FromUserId
	}
	return 0
}

type MarkPrescriptionMessageResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkPrescriptionMessageResp) Reset()         { *m = MarkPrescriptionMessageResp{} }
func (m *MarkPrescriptionMessageResp) String() string { return proto.CompactTextString(m) }
func (*MarkPrescriptionMessageResp) ProtoMessage()    {}
func (*MarkPrescriptionMessageResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{36}
}
func (m *MarkPrescriptionMessageResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkPrescriptionMessageResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkPrescriptionMessageResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkPrescriptionMessageResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkPrescriptionMessageResp.Merge(m, src)
}
func (m *MarkPrescriptionMessageResp) XXX_Size() int {
	return m.Size()
}
func (m *MarkPrescriptionMessageResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkPrescriptionMessageResp.DiscardUnknown(m)
}

var xxx_messageInfo_MarkPrescriptionMessageResp proto.InternalMessageInfo

type UnMarkPrescriptionMessageReq struct {
	// 登录用户id
	UserId int64 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	// 列表用户id 医生/患者
	OtherUserId int64 `protobuf:"varint,2,opt,name=otherUserId,proto3" json:"otherUserId,omitempty" form:"otherUserId"`
	// groupId
	GroupId              int64    `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnMarkPrescriptionMessageReq) Reset()         { *m = UnMarkPrescriptionMessageReq{} }
func (m *UnMarkPrescriptionMessageReq) String() string { return proto.CompactTextString(m) }
func (*UnMarkPrescriptionMessageReq) ProtoMessage()    {}
func (*UnMarkPrescriptionMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{37}
}
func (m *UnMarkPrescriptionMessageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnMarkPrescriptionMessageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnMarkPrescriptionMessageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnMarkPrescriptionMessageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnMarkPrescriptionMessageReq.Merge(m, src)
}
func (m *UnMarkPrescriptionMessageReq) XXX_Size() int {
	return m.Size()
}
func (m *UnMarkPrescriptionMessageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnMarkPrescriptionMessageReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnMarkPrescriptionMessageReq proto.InternalMessageInfo

func (m *UnMarkPrescriptionMessageReq) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UnMarkPrescriptionMessageReq) GetOtherUserId() int64 {
	if m != nil {
		return m.OtherUserId
	}
	return 0
}

func (m *UnMarkPrescriptionMessageReq) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type UnMarkPrescriptionMessageResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnMarkPrescriptionMessageResp) Reset()         { *m = UnMarkPrescriptionMessageResp{} }
func (m *UnMarkPrescriptionMessageResp) String() string { return proto.CompactTextString(m) }
func (*UnMarkPrescriptionMessageResp) ProtoMessage()    {}
func (*UnMarkPrescriptionMessageResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{38}
}
func (m *UnMarkPrescriptionMessageResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnMarkPrescriptionMessageResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnMarkPrescriptionMessageResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnMarkPrescriptionMessageResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnMarkPrescriptionMessageResp.Merge(m, src)
}
func (m *UnMarkPrescriptionMessageResp) XXX_Size() int {
	return m.Size()
}
func (m *UnMarkPrescriptionMessageResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UnMarkPrescriptionMessageResp.DiscardUnknown(m)
}

var xxx_messageInfo_UnMarkPrescriptionMessageResp proto.InternalMessageInfo

type MessageHandleReq struct {
	CliV                 string   `protobuf:"bytes,1,opt,name=cli_v,json=cliV,proto3" json:"cli_v,omitempty" form:"cli_v"`
	SysP                 string   `protobuf:"bytes,2,opt,name=sys_p,json=sysP,proto3" json:"sys_p,omitempty" form:"sys_p"`
	XPlatform            string   `protobuf:"bytes,3,opt,name=x_platform,json=xPlatform,proto3" json:"x_platform,omitempty" form:"x_platform"`
	Content              string   `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	UserId               int32    `protobuf:"varint,5,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageHandleReq) Reset()         { *m = MessageHandleReq{} }
func (m *MessageHandleReq) String() string { return proto.CompactTextString(m) }
func (*MessageHandleReq) ProtoMessage()    {}
func (*MessageHandleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{39}
}
func (m *MessageHandleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageHandleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageHandleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageHandleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageHandleReq.Merge(m, src)
}
func (m *MessageHandleReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageHandleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageHandleReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageHandleReq proto.InternalMessageInfo

func (m *MessageHandleReq) GetCliV() string {
	if m != nil {
		return m.CliV
	}
	return ""
}

func (m *MessageHandleReq) GetSysP() string {
	if m != nil {
		return m.SysP
	}
	return ""
}

func (m *MessageHandleReq) GetXPlatform() string {
	if m != nil {
		return m.XPlatform
	}
	return ""
}

func (m *MessageHandleReq) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *MessageHandleReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type MessageHandleResp struct {
	MsgId                int64    `protobuf:"varint,1,opt,name=msgId,proto3" json:"msgId"`
	Info                 string   `protobuf:"bytes,2,opt,name=info,proto3" json:"info"`
	MsgIdStr             string   `protobuf:"bytes,3,opt,name=msgIdStr,proto3" json:"msgIdStr"`
	Offline              []int64  `protobuf:"varint,4,rep,packed,name=offline,proto3" json:"offline"`
	GroupId              int32    `protobuf:"varint,5,opt,name=groupId,proto3" json:"groupId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageHandleResp) Reset()         { *m = MessageHandleResp{} }
func (m *MessageHandleResp) String() string { return proto.CompactTextString(m) }
func (*MessageHandleResp) ProtoMessage()    {}
func (*MessageHandleResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{40}
}
func (m *MessageHandleResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageHandleResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageHandleResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageHandleResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageHandleResp.Merge(m, src)
}
func (m *MessageHandleResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageHandleResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageHandleResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageHandleResp proto.InternalMessageInfo

func (m *MessageHandleResp) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *MessageHandleResp) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *MessageHandleResp) GetMsgIdStr() string {
	if m != nil {
		return m.MsgIdStr
	}
	return ""
}

func (m *MessageHandleResp) GetOffline() []int64 {
	if m != nil {
		return m.Offline
	}
	return nil
}

func (m *MessageHandleResp) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type MessageGetHistoryReq struct {
	//会话方用户id
	ToId int32 `protobuf:"varint,1,opt,name=toId,proto3" json:"toId,omitempty" form:"toId"`
	//会话方用户类型
	ToRef int32 `protobuf:"varint,2,opt,name=toRef,proto3" json:"toRef,omitempty" form:"toRef"`
	//会话id
	HashId int32 `protobuf:"varint,3,opt,name=hashId,proto3" json:"hashId,omitempty" form:"hashId"`
	//群组id
	GroupId int32 `protobuf:"varint,4,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	//条数条数
	Limit int32 `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty" form:"limit"`
	Begin int64 `protobuf:"varint,6,opt,name=begin,proto3" json:"begin,omitempty" form:"begin"`
	End   int64 `protobuf:"varint,7,opt,name=end,proto3" json:"end,omitempty" form:"end"`
	//偏移量
	Start int32 `protobuf:"varint,8,opt,name=start,proto3" json:"start,omitempty" form:"start"`
	//偏序 1倒序 0正序
	Sort                 int32    `protobuf:"varint,9,opt,name=sort,proto3" json:"sort,omitempty" form:"sort"`
	Index                string   `protobuf:"bytes,10,opt,name=index,proto3" json:"index,omitempty" form:"index"`
	UserId               int32    `protobuf:"varint,11,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetHistoryReq) Reset()         { *m = MessageGetHistoryReq{} }
func (m *MessageGetHistoryReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetHistoryReq) ProtoMessage()    {}
func (*MessageGetHistoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{41}
}
func (m *MessageGetHistoryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetHistoryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetHistoryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetHistoryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetHistoryReq.Merge(m, src)
}
func (m *MessageGetHistoryReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetHistoryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetHistoryReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetHistoryReq proto.InternalMessageInfo

func (m *MessageGetHistoryReq) GetToId() int32 {
	if m != nil {
		return m.ToId
	}
	return 0
}

func (m *MessageGetHistoryReq) GetToRef() int32 {
	if m != nil {
		return m.ToRef
	}
	return 0
}

func (m *MessageGetHistoryReq) GetHashId() int32 {
	if m != nil {
		return m.HashId
	}
	return 0
}

func (m *MessageGetHistoryReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *MessageGetHistoryReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *MessageGetHistoryReq) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *MessageGetHistoryReq) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *MessageGetHistoryReq) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MessageGetHistoryReq) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *MessageGetHistoryReq) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

func (m *MessageGetHistoryReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type MessageGetHistoryResp struct {
	Start                int32    `protobuf:"varint,1,opt,name=start,proto3" json:"start"`
	More                 bool     `protobuf:"varint,2,opt,name=more,proto3" json:"more"`
	Index                int64    `protobuf:"varint,3,opt,name=index,proto3" json:"index"`
	List                 []string `protobuf:"bytes,4,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetHistoryResp) Reset()         { *m = MessageGetHistoryResp{} }
func (m *MessageGetHistoryResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetHistoryResp) ProtoMessage()    {}
func (*MessageGetHistoryResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{42}
}
func (m *MessageGetHistoryResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetHistoryResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetHistoryResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetHistoryResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetHistoryResp.Merge(m, src)
}
func (m *MessageGetHistoryResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetHistoryResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetHistoryResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetHistoryResp proto.InternalMessageInfo

func (m *MessageGetHistoryResp) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MessageGetHistoryResp) GetMore() bool {
	if m != nil {
		return m.More
	}
	return false
}

func (m *MessageGetHistoryResp) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MessageGetHistoryResp) GetList() []string {
	if m != nil {
		return m.List
	}
	return nil
}

type MessageGetSysHistoryReq struct {
	//系统角色id
	RoleId int32 `protobuf:"varint,1,opt,name=roleId,proto3" json:"roleId,omitempty" form:"roleId"`
	//条数
	Limit int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty" form:"limit"`
	//偏移量
	Start                int32    `protobuf:"varint,3,opt,name=start,proto3" json:"start,omitempty" form:"start"`
	UserId               int32    `protobuf:"varint,4,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetSysHistoryReq) Reset()         { *m = MessageGetSysHistoryReq{} }
func (m *MessageGetSysHistoryReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetSysHistoryReq) ProtoMessage()    {}
func (*MessageGetSysHistoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{43}
}
func (m *MessageGetSysHistoryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetSysHistoryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetSysHistoryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetSysHistoryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetSysHistoryReq.Merge(m, src)
}
func (m *MessageGetSysHistoryReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetSysHistoryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetSysHistoryReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetSysHistoryReq proto.InternalMessageInfo

func (m *MessageGetSysHistoryReq) GetRoleId() int32 {
	if m != nil {
		return m.RoleId
	}
	return 0
}

func (m *MessageGetSysHistoryReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *MessageGetSysHistoryReq) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MessageGetSysHistoryReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type MessageGetSysHistoryResp struct {
	Start                int32    `protobuf:"varint,1,opt,name=start,proto3" json:"start"`
	More                 bool     `protobuf:"varint,2,opt,name=more,proto3" json:"more"`
	Index                int64    `protobuf:"varint,3,opt,name=index,proto3" json:"index"`
	List                 []string `protobuf:"bytes,4,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetSysHistoryResp) Reset()         { *m = MessageGetSysHistoryResp{} }
func (m *MessageGetSysHistoryResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetSysHistoryResp) ProtoMessage()    {}
func (*MessageGetSysHistoryResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{44}
}
func (m *MessageGetSysHistoryResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetSysHistoryResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetSysHistoryResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetSysHistoryResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetSysHistoryResp.Merge(m, src)
}
func (m *MessageGetSysHistoryResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetSysHistoryResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetSysHistoryResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetSysHistoryResp proto.InternalMessageInfo

func (m *MessageGetSysHistoryResp) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MessageGetSysHistoryResp) GetMore() bool {
	if m != nil {
		return m.More
	}
	return false
}

func (m *MessageGetSysHistoryResp) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MessageGetSysHistoryResp) GetList() []string {
	if m != nil {
		return m.List
	}
	return nil
}

type MessageGetOfflineReq struct {
	UserId               int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetOfflineReq) Reset()         { *m = MessageGetOfflineReq{} }
func (m *MessageGetOfflineReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetOfflineReq) ProtoMessage()    {}
func (*MessageGetOfflineReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{45}
}
func (m *MessageGetOfflineReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetOfflineReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetOfflineReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetOfflineReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetOfflineReq.Merge(m, src)
}
func (m *MessageGetOfflineReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetOfflineReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetOfflineReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetOfflineReq proto.InternalMessageInfo

func (m *MessageGetOfflineReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type MessageGetOfflineResp struct {
	List                 []string `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetOfflineResp) Reset()         { *m = MessageGetOfflineResp{} }
func (m *MessageGetOfflineResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetOfflineResp) ProtoMessage()    {}
func (*MessageGetOfflineResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{46}
}
func (m *MessageGetOfflineResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetOfflineResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetOfflineResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetOfflineResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetOfflineResp.Merge(m, src)
}
func (m *MessageGetOfflineResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetOfflineResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetOfflineResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetOfflineResp proto.InternalMessageInfo

func (m *MessageGetOfflineResp) GetList() []string {
	if m != nil {
		return m.List
	}
	return nil
}

type MessageGetOfflineCountReq struct {
	UserId               int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetOfflineCountReq) Reset()         { *m = MessageGetOfflineCountReq{} }
func (m *MessageGetOfflineCountReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetOfflineCountReq) ProtoMessage()    {}
func (*MessageGetOfflineCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{47}
}
func (m *MessageGetOfflineCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetOfflineCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetOfflineCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetOfflineCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetOfflineCountReq.Merge(m, src)
}
func (m *MessageGetOfflineCountReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetOfflineCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetOfflineCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetOfflineCountReq proto.InternalMessageInfo

func (m *MessageGetOfflineCountReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type MessageGetOfflineCountResp struct {
	Count                int32    `protobuf:"varint,1,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetOfflineCountResp) Reset()         { *m = MessageGetOfflineCountResp{} }
func (m *MessageGetOfflineCountResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetOfflineCountResp) ProtoMessage()    {}
func (*MessageGetOfflineCountResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{48}
}
func (m *MessageGetOfflineCountResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetOfflineCountResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetOfflineCountResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetOfflineCountResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetOfflineCountResp.Merge(m, src)
}
func (m *MessageGetOfflineCountResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetOfflineCountResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetOfflineCountResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetOfflineCountResp proto.InternalMessageInfo

func (m *MessageGetOfflineCountResp) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type MessageGetReceiptReq struct {
	//消息id
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" form:"id"`
	UserId               int32    `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetReceiptReq) Reset()         { *m = MessageGetReceiptReq{} }
func (m *MessageGetReceiptReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetReceiptReq) ProtoMessage()    {}
func (*MessageGetReceiptReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{49}
}
func (m *MessageGetReceiptReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetReceiptReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetReceiptReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetReceiptReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetReceiptReq.Merge(m, src)
}
func (m *MessageGetReceiptReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetReceiptReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetReceiptReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetReceiptReq proto.InternalMessageInfo

func (m *MessageGetReceiptReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MessageGetReceiptReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type MessageGetReceiptResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetReceiptResp) Reset()         { *m = MessageGetReceiptResp{} }
func (m *MessageGetReceiptResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetReceiptResp) ProtoMessage()    {}
func (*MessageGetReceiptResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{50}
}
func (m *MessageGetReceiptResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetReceiptResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetReceiptResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetReceiptResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetReceiptResp.Merge(m, src)
}
func (m *MessageGetReceiptResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetReceiptResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetReceiptResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetReceiptResp proto.InternalMessageInfo

type MessageGetChatlistReq struct {
	UserId               int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetChatlistReq) Reset()         { *m = MessageGetChatlistReq{} }
func (m *MessageGetChatlistReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetChatlistReq) ProtoMessage()    {}
func (*MessageGetChatlistReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{51}
}
func (m *MessageGetChatlistReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetChatlistReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetChatlistReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetChatlistReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetChatlistReq.Merge(m, src)
}
func (m *MessageGetChatlistReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetChatlistReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetChatlistReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetChatlistReq proto.InternalMessageInfo

func (m *MessageGetChatlistReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type MessageGetChatlistResp struct {
	Data                 map[string]string `protobuf:"bytes,1,rep,name=data,proto3" json:"data" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MessageGetChatlistResp) Reset()         { *m = MessageGetChatlistResp{} }
func (m *MessageGetChatlistResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetChatlistResp) ProtoMessage()    {}
func (*MessageGetChatlistResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{52}
}
func (m *MessageGetChatlistResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetChatlistResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetChatlistResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetChatlistResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetChatlistResp.Merge(m, src)
}
func (m *MessageGetChatlistResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetChatlistResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetChatlistResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetChatlistResp proto.InternalMessageInfo

func (m *MessageGetChatlistResp) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type MessageGetLocalReq struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" form:"key"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" form:"value"`
	UserId               int32    `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	Method               string   `protobuf:"bytes,4,opt,name=method,proto3" json:"method,omitempty" form:"method"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetLocalReq) Reset()         { *m = MessageGetLocalReq{} }
func (m *MessageGetLocalReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetLocalReq) ProtoMessage()    {}
func (*MessageGetLocalReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{53}
}
func (m *MessageGetLocalReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetLocalReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetLocalReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetLocalReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetLocalReq.Merge(m, src)
}
func (m *MessageGetLocalReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetLocalReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetLocalReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetLocalReq proto.InternalMessageInfo

func (m *MessageGetLocalReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *MessageGetLocalReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *MessageGetLocalReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MessageGetLocalReq) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

type MessageGetLocalResp struct {
	Data                 string   `protobuf:"bytes,1,opt,name=data,proto3" json:"data"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetLocalResp) Reset()         { *m = MessageGetLocalResp{} }
func (m *MessageGetLocalResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetLocalResp) ProtoMessage()    {}
func (*MessageGetLocalResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{54}
}
func (m *MessageGetLocalResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetLocalResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetLocalResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetLocalResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetLocalResp.Merge(m, src)
}
func (m *MessageGetLocalResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetLocalResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetLocalResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetLocalResp proto.InternalMessageInfo

func (m *MessageGetLocalResp) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type MessageDelChatReq struct {
	UserId               int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	TargetUserId         int32    `protobuf:"varint,2,opt,name=targetUserId,proto3" json:"targetUserId,omitempty" form:"targetUserId"`
	TargetUserRef        int32    `protobuf:"varint,3,opt,name=targetUserRef,proto3" json:"targetUserRef,omitempty" form:"targetUserRef"`
	GroupId              int32    `protobuf:"varint,4,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	MapKeys              string   `protobuf:"bytes,5,opt,name=mapKeys,proto3" json:"mapKeys,omitempty" form:"mapKeys"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageDelChatReq) Reset()         { *m = MessageDelChatReq{} }
func (m *MessageDelChatReq) String() string { return proto.CompactTextString(m) }
func (*MessageDelChatReq) ProtoMessage()    {}
func (*MessageDelChatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{55}
}
func (m *MessageDelChatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageDelChatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageDelChatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageDelChatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageDelChatReq.Merge(m, src)
}
func (m *MessageDelChatReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageDelChatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageDelChatReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageDelChatReq proto.InternalMessageInfo

func (m *MessageDelChatReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MessageDelChatReq) GetTargetUserId() int32 {
	if m != nil {
		return m.TargetUserId
	}
	return 0
}

func (m *MessageDelChatReq) GetTargetUserRef() int32 {
	if m != nil {
		return m.TargetUserRef
	}
	return 0
}

func (m *MessageDelChatReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *MessageDelChatReq) GetMapKeys() string {
	if m != nil {
		return m.MapKeys
	}
	return ""
}

type MessageDelChatResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageDelChatResp) Reset()         { *m = MessageDelChatResp{} }
func (m *MessageDelChatResp) String() string { return proto.CompactTextString(m) }
func (*MessageDelChatResp) ProtoMessage()    {}
func (*MessageDelChatResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{56}
}
func (m *MessageDelChatResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageDelChatResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageDelChatResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageDelChatResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageDelChatResp.Merge(m, src)
}
func (m *MessageDelChatResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageDelChatResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageDelChatResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageDelChatResp proto.InternalMessageInfo

type MessageGetPatientChatListReq struct {
	UserId               int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetPatientChatListReq) Reset()         { *m = MessageGetPatientChatListReq{} }
func (m *MessageGetPatientChatListReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetPatientChatListReq) ProtoMessage()    {}
func (*MessageGetPatientChatListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{57}
}
func (m *MessageGetPatientChatListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetPatientChatListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetPatientChatListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetPatientChatListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetPatientChatListReq.Merge(m, src)
}
func (m *MessageGetPatientChatListReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetPatientChatListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetPatientChatListReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetPatientChatListReq proto.InternalMessageInfo

func (m *MessageGetPatientChatListReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type MessageGetPatientChatListResp struct {
	ChatList             []*GetPatientChatList `protobuf:"bytes,1,rep,name=chatList,proto3" json:"chatList"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MessageGetPatientChatListResp) Reset()         { *m = MessageGetPatientChatListResp{} }
func (m *MessageGetPatientChatListResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetPatientChatListResp) ProtoMessage()    {}
func (*MessageGetPatientChatListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{58}
}
func (m *MessageGetPatientChatListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetPatientChatListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetPatientChatListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetPatientChatListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetPatientChatListResp.Merge(m, src)
}
func (m *MessageGetPatientChatListResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetPatientChatListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetPatientChatListResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetPatientChatListResp proto.InternalMessageInfo

func (m *MessageGetPatientChatListResp) GetChatList() []*GetPatientChatList {
	if m != nil {
		return m.ChatList
	}
	return nil
}

type GetPatientChatList struct {
	MapId                string   `protobuf:"bytes,1,opt,name=mapId,proto3" json:"mapId"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message"`
	DoctorId             int32    `protobuf:"varint,3,opt,name=doctorId,proto3" json:"doctorId"`
	DoctorName           string   `protobuf:"bytes,4,opt,name=doctorName,proto3" json:"doctorName"`
	DoctorAvatar         string   `protobuf:"bytes,5,opt,name=doctorAvatar,proto3" json:"doctorAvatar"`
	AssistantId          int32    `protobuf:"varint,6,opt,name=assistantId,proto3" json:"assistantId"`
	AssistantName        string   `protobuf:"bytes,7,opt,name=assistantName,proto3" json:"assistantName"`
	AssistantAvatar      string   `protobuf:"bytes,8,opt,name=assistantAvatar,proto3" json:"assistantAvatar"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPatientChatList) Reset()         { *m = GetPatientChatList{} }
func (m *GetPatientChatList) String() string { return proto.CompactTextString(m) }
func (*GetPatientChatList) ProtoMessage()    {}
func (*GetPatientChatList) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{59}
}
func (m *GetPatientChatList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPatientChatList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPatientChatList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPatientChatList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPatientChatList.Merge(m, src)
}
func (m *GetPatientChatList) XXX_Size() int {
	return m.Size()
}
func (m *GetPatientChatList) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPatientChatList.DiscardUnknown(m)
}

var xxx_messageInfo_GetPatientChatList proto.InternalMessageInfo

func (m *GetPatientChatList) GetMapId() string {
	if m != nil {
		return m.MapId
	}
	return ""
}

func (m *GetPatientChatList) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GetPatientChatList) GetDoctorId() int32 {
	if m != nil {
		return m.DoctorId
	}
	return 0
}

func (m *GetPatientChatList) GetDoctorName() string {
	if m != nil {
		return m.DoctorName
	}
	return ""
}

func (m *GetPatientChatList) GetDoctorAvatar() string {
	if m != nil {
		return m.DoctorAvatar
	}
	return ""
}

func (m *GetPatientChatList) GetAssistantId() int32 {
	if m != nil {
		return m.AssistantId
	}
	return 0
}

func (m *GetPatientChatList) GetAssistantName() string {
	if m != nil {
		return m.AssistantName
	}
	return ""
}

func (m *GetPatientChatList) GetAssistantAvatar() string {
	if m != nil {
		return m.AssistantAvatar
	}
	return ""
}

type MessageGetImMenuReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty" form:"type"`
	RnVersion            int32    `protobuf:"varint,2,opt,name=rn_version,json=rnVersion,proto3" json:"rn_version,omitempty" form:"rn_version"`
	NvVersion            int32    `protobuf:"varint,3,opt,name=nv_version,json=nvVersion,proto3" json:"nv_version,omitempty" form:"nv_version"`
	GroupId              int32    `protobuf:"varint,4,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty" form:"group_id"`
	Mplatform            string   `protobuf:"bytes,5,opt,name=mplatform,proto3" json:"mplatform,omitempty" form:"mplatform"`
	DiseaseTagId         int32    `protobuf:"varint,6,opt,name=disease_tag_id,json=diseaseTagId,proto3" json:"disease_tag_id,omitempty" form:"disease_tag_id"`
	DoctorId             int32    `protobuf:"varint,7,opt,name=doctor_id,json=doctorId,proto3" json:"doctor_id,omitempty" form:"doctor_id"`
	PatientId            int32    `protobuf:"varint,8,opt,name=patient_id,json=patientId,proto3" json:"patient_id,omitempty" form:"patient_id"`
	UserId               int32    `protobuf:"varint,9,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	CliV                 string   `protobuf:"bytes,10,opt,name=cli_v,json=cliV,proto3" json:"cli_v,omitempty" form:"cli_v"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageGetImMenuReq) Reset()         { *m = MessageGetImMenuReq{} }
func (m *MessageGetImMenuReq) String() string { return proto.CompactTextString(m) }
func (*MessageGetImMenuReq) ProtoMessage()    {}
func (*MessageGetImMenuReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{60}
}
func (m *MessageGetImMenuReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetImMenuReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetImMenuReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetImMenuReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetImMenuReq.Merge(m, src)
}
func (m *MessageGetImMenuReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetImMenuReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetImMenuReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetImMenuReq proto.InternalMessageInfo

func (m *MessageGetImMenuReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *MessageGetImMenuReq) GetRnVersion() int32 {
	if m != nil {
		return m.RnVersion
	}
	return 0
}

func (m *MessageGetImMenuReq) GetNvVersion() int32 {
	if m != nil {
		return m.NvVersion
	}
	return 0
}

func (m *MessageGetImMenuReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *MessageGetImMenuReq) GetMplatform() string {
	if m != nil {
		return m.Mplatform
	}
	return ""
}

func (m *MessageGetImMenuReq) GetDiseaseTagId() int32 {
	if m != nil {
		return m.DiseaseTagId
	}
	return 0
}

func (m *MessageGetImMenuReq) GetDoctorId() int32 {
	if m != nil {
		return m.DoctorId
	}
	return 0
}

func (m *MessageGetImMenuReq) GetPatientId() int32 {
	if m != nil {
		return m.PatientId
	}
	return 0
}

func (m *MessageGetImMenuReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MessageGetImMenuReq) GetCliV() string {
	if m != nil {
		return m.CliV
	}
	return ""
}

type MessageGetImMenuResp struct {
	List                 []*MenuFields `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MessageGetImMenuResp) Reset()         { *m = MessageGetImMenuResp{} }
func (m *MessageGetImMenuResp) String() string { return proto.CompactTextString(m) }
func (*MessageGetImMenuResp) ProtoMessage()    {}
func (*MessageGetImMenuResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{61}
}
func (m *MessageGetImMenuResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageGetImMenuResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageGetImMenuResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageGetImMenuResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageGetImMenuResp.Merge(m, src)
}
func (m *MessageGetImMenuResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageGetImMenuResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageGetImMenuResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageGetImMenuResp proto.InternalMessageInfo

func (m *MessageGetImMenuResp) GetList() []*MenuFields {
	if m != nil {
		return m.List
	}
	return nil
}

type MenuFields struct {
	PkId                 int32    `protobuf:"varint,1,opt,name=pkId,proto3" json:"pkId"`
	Id                   int32    `protobuf:"varint,2,opt,name=id,proto3" json:"id"`
	Title                string   `protobuf:"bytes,3,opt,name=title,proto3" json:"title"`
	Type                 int32    `protobuf:"varint,4,opt,name=type,proto3" json:"type"`
	JumpType             int32    `protobuf:"varint,5,opt,name=jumpType,proto3" json:"jumpType"`
	MinVersion           int32    `protobuf:"varint,6,opt,name=minVersion,proto3" json:"minVersion"`
	MaxVersion           int32    `protobuf:"varint,7,opt,name=maxVersion,proto3" json:"maxVersion"`
	Icon                 string   `protobuf:"bytes,8,opt,name=icon,proto3" json:"icon"`
	JumpUrl              string   `protobuf:"bytes,9,opt,name=jumpUrl,proto3" json:"jumpUrl"`
	Check                int32    `protobuf:"varint,10,opt,name=check,proto3" json:"check"`
	Sort                 int32    `protobuf:"varint,11,opt,name=sort,proto3" json:"sort"`
	Mplatform            string   `protobuf:"bytes,12,opt,name=mplatform,proto3" json:"mplatform"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MenuFields) Reset()         { *m = MenuFields{} }
func (m *MenuFields) String() string { return proto.CompactTextString(m) }
func (*MenuFields) ProtoMessage()    {}
func (*MenuFields) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{62}
}
func (m *MenuFields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MenuFields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MenuFields.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MenuFields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MenuFields.Merge(m, src)
}
func (m *MenuFields) XXX_Size() int {
	return m.Size()
}
func (m *MenuFields) XXX_DiscardUnknown() {
	xxx_messageInfo_MenuFields.DiscardUnknown(m)
}

var xxx_messageInfo_MenuFields proto.InternalMessageInfo

func (m *MenuFields) GetPkId() int32 {
	if m != nil {
		return m.PkId
	}
	return 0
}

func (m *MenuFields) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MenuFields) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MenuFields) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *MenuFields) GetJumpType() int32 {
	if m != nil {
		return m.JumpType
	}
	return 0
}

func (m *MenuFields) GetMinVersion() int32 {
	if m != nil {
		return m.MinVersion
	}
	return 0
}

func (m *MenuFields) GetMaxVersion() int32 {
	if m != nil {
		return m.MaxVersion
	}
	return 0
}

func (m *MenuFields) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *MenuFields) GetJumpUrl() string {
	if m != nil {
		return m.JumpUrl
	}
	return ""
}

func (m *MenuFields) GetCheck() int32 {
	if m != nil {
		return m.Check
	}
	return 0
}

func (m *MenuFields) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *MenuFields) GetMplatform() string {
	if m != nil {
		return m.Mplatform
	}
	return ""
}

type MessageRpcSendSystemReq struct {
	// 系统消息类型
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty" form:"type"`
	// 接收系统消息用户ids
	UserIds []int32 `protobuf:"varint,2,rep,packed,name=userIds,proto3" json:"userIds,omitempty" form:"userIds"`
	// 其他参数
	Cols *SendSystemCols `protobuf:"bytes,3,opt,name=cols,proto3" json:"cols,omitempty" form:"cols"`
	// 发送者id
	SenderId int32 `protobuf:"varint,4,opt,name=senderId,proto3" json:"senderId,omitempty" form:"senderId"`
	Delay    bool  `protobuf:"varint,5,opt,name=delay,proto3" json:"delay,omitempty" form:"delay"`
	// 可扩展字段
	Ext                  string   `protobuf:"bytes,6,opt,name=ext,proto3" json:"ext,omitempty" form:"ext"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcSendSystemReq) Reset()         { *m = MessageRpcSendSystemReq{} }
func (m *MessageRpcSendSystemReq) String() string { return proto.CompactTextString(m) }
func (*MessageRpcSendSystemReq) ProtoMessage()    {}
func (*MessageRpcSendSystemReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{63}
}
func (m *MessageRpcSendSystemReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcSendSystemReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcSendSystemReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcSendSystemReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcSendSystemReq.Merge(m, src)
}
func (m *MessageRpcSendSystemReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcSendSystemReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcSendSystemReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcSendSystemReq proto.InternalMessageInfo

func (m *MessageRpcSendSystemReq) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MessageRpcSendSystemReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *MessageRpcSendSystemReq) GetCols() *SendSystemCols {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *MessageRpcSendSystemReq) GetSenderId() int32 {
	if m != nil {
		return m.SenderId
	}
	return 0
}

func (m *MessageRpcSendSystemReq) GetDelay() bool {
	if m != nil {
		return m.Delay
	}
	return false
}

func (m *MessageRpcSendSystemReq) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

type SendSystemCols struct {
	// cols 类型
	Type int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty" form:"type"`
	// cols 内容 SendSystemContent
	Content string    `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	Anchors []*Anchor `protobuf:"bytes,3,rep,name=anchors,proto3" json:"anchors,omitempty" form:"anchors"`
	// card 需要字段
	Label                string   `protobuf:"bytes,4,opt,name=label,proto3" json:"label,omitempty" form:"label"`
	Title                string   `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty" form:"title"`
	Subtitle             string   `protobuf:"bytes,6,opt,name=subtitle,proto3" json:"subtitle,omitempty" form:"subtitle"`
	Summary              string   `protobuf:"bytes,7,opt,name=summary,proto3" json:"summary,omitempty" form:"summary"`
	Image                string   `protobuf:"bytes,8,opt,name=image,proto3" json:"image,omitempty" form:"image"`
	Url                  string   `protobuf:"bytes,9,opt,name=url,proto3" json:"url,omitempty" form:"url"`
	Display              int32    `protobuf:"varint,10,opt,name=display,proto3" json:"display,omitempty" form:"display"`
	Extra                string   `protobuf:"bytes,11,opt,name=extra,proto3" json:"extra,omitempty" form:"extra"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendSystemCols) Reset()         { *m = SendSystemCols{} }
func (m *SendSystemCols) String() string { return proto.CompactTextString(m) }
func (*SendSystemCols) ProtoMessage()    {}
func (*SendSystemCols) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{64}
}
func (m *SendSystemCols) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendSystemCols) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendSystemCols.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendSystemCols) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSystemCols.Merge(m, src)
}
func (m *SendSystemCols) XXX_Size() int {
	return m.Size()
}
func (m *SendSystemCols) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSystemCols.DiscardUnknown(m)
}

var xxx_messageInfo_SendSystemCols proto.InternalMessageInfo

func (m *SendSystemCols) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *SendSystemCols) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *SendSystemCols) GetAnchors() []*Anchor {
	if m != nil {
		return m.Anchors
	}
	return nil
}

func (m *SendSystemCols) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *SendSystemCols) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SendSystemCols) GetSubtitle() string {
	if m != nil {
		return m.Subtitle
	}
	return ""
}

func (m *SendSystemCols) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *SendSystemCols) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *SendSystemCols) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *SendSystemCols) GetDisplay() int32 {
	if m != nil {
		return m.Display
	}
	return 0
}

func (m *SendSystemCols) GetExtra() string {
	if m != nil {
		return m.Extra
	}
	return ""
}

type Anchor struct {
	Href                 string   `protobuf:"bytes,1,opt,name=href,proto3" json:"href,omitempty" form:"href"`
	Start                int32    `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty" form:"start"`
	Len                  int32    `protobuf:"varint,3,opt,name=len,proto3" json:"len,omitempty" form:"len"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Anchor) Reset()         { *m = Anchor{} }
func (m *Anchor) String() string { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()    {}
func (*Anchor) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{65}
}
func (m *Anchor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Anchor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Anchor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Anchor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Anchor.Merge(m, src)
}
func (m *Anchor) XXX_Size() int {
	return m.Size()
}
func (m *Anchor) XXX_DiscardUnknown() {
	xxx_messageInfo_Anchor.DiscardUnknown(m)
}

var xxx_messageInfo_Anchor proto.InternalMessageInfo

func (m *Anchor) GetHref() string {
	if m != nil {
		return m.Href
	}
	return ""
}

func (m *Anchor) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Anchor) GetLen() int32 {
	if m != nil {
		return m.Len
	}
	return 0
}

type MessageRpcSendSystemResp struct {
	Result               bool     `protobuf:"varint,1,opt,name=result,proto3" json:"result"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcSendSystemResp) Reset()         { *m = MessageRpcSendSystemResp{} }
func (m *MessageRpcSendSystemResp) String() string { return proto.CompactTextString(m) }
func (*MessageRpcSendSystemResp) ProtoMessage()    {}
func (*MessageRpcSendSystemResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{66}
}
func (m *MessageRpcSendSystemResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcSendSystemResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcSendSystemResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcSendSystemResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcSendSystemResp.Merge(m, src)
}
func (m *MessageRpcSendSystemResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcSendSystemResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcSendSystemResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcSendSystemResp proto.InternalMessageInfo

func (m *MessageRpcSendSystemResp) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type MessageRpcHandleReq struct {
	// 系统消息结构 protobuf base64之后的字符串
	Data string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty" form:"data"`
	// 是否是代理消息 true/false 默认都不需要传
	FromProxy bool `protobuf:"varint,2,opt,name=fromProxy,proto3" json:"fromProxy,omitempty" form:"fromProxy"`
	// 特殊需求，消息不计入回合数标识，true不计入，false计入，不传默认是false
	IsNotNeedRound       bool     `protobuf:"varint,3,opt,name=isNotNeedRound,proto3" json:"isNotNeedRound,omitempty" form:"isNotNeedRound"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcHandleReq) Reset()         { *m = MessageRpcHandleReq{} }
func (m *MessageRpcHandleReq) String() string { return proto.CompactTextString(m) }
func (*MessageRpcHandleReq) ProtoMessage()    {}
func (*MessageRpcHandleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{67}
}
func (m *MessageRpcHandleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcHandleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcHandleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcHandleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcHandleReq.Merge(m, src)
}
func (m *MessageRpcHandleReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcHandleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcHandleReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcHandleReq proto.InternalMessageInfo

func (m *MessageRpcHandleReq) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *MessageRpcHandleReq) GetFromProxy() bool {
	if m != nil {
		return m.FromProxy
	}
	return false
}

func (m *MessageRpcHandleReq) GetIsNotNeedRound() bool {
	if m != nil {
		return m.IsNotNeedRound
	}
	return false
}

type MessageRpcHandleResp struct {
	MsgId                int64    `protobuf:"varint,1,opt,name=msgId,proto3" json:"msgId"`
	Info                 string   `protobuf:"bytes,2,opt,name=info,proto3" json:"info"`
	MsgIdStr             string   `protobuf:"bytes,3,opt,name=msgIdStr,proto3" json:"msgIdStr"`
	Offline              []int64  `protobuf:"varint,4,rep,packed,name=offline,proto3" json:"offline"`
	GroupId              int32    `protobuf:"varint,5,opt,name=groupId,proto3" json:"groupId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcHandleResp) Reset()         { *m = MessageRpcHandleResp{} }
func (m *MessageRpcHandleResp) String() string { return proto.CompactTextString(m) }
func (*MessageRpcHandleResp) ProtoMessage()    {}
func (*MessageRpcHandleResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{68}
}
func (m *MessageRpcHandleResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcHandleResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcHandleResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcHandleResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcHandleResp.Merge(m, src)
}
func (m *MessageRpcHandleResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcHandleResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcHandleResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcHandleResp proto.InternalMessageInfo

func (m *MessageRpcHandleResp) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *MessageRpcHandleResp) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *MessageRpcHandleResp) GetMsgIdStr() string {
	if m != nil {
		return m.MsgIdStr
	}
	return ""
}

func (m *MessageRpcHandleResp) GetOffline() []int64 {
	if m != nil {
		return m.Offline
	}
	return nil
}

func (m *MessageRpcHandleResp) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type MessageRpcHandleMultiReq struct {
	SendId               int64    `protobuf:"varint,1,opt,name=sendId,proto3" json:"sendId,omitempty" form:"sendId"`
	GroupIds             []int64  `protobuf:"varint,2,rep,packed,name=groupIds,proto3" json:"groupIds,omitempty" form:"groupIds"`
	ImageUrls            []string `protobuf:"bytes,3,rep,name=imageUrls,proto3" json:"imageUrls,omitempty" form:"imageUrls"`
	Content              string   `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty" form:"content"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcHandleMultiReq) Reset()         { *m = MessageRpcHandleMultiReq{} }
func (m *MessageRpcHandleMultiReq) String() string { return proto.CompactTextString(m) }
func (*MessageRpcHandleMultiReq) ProtoMessage()    {}
func (*MessageRpcHandleMultiReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{69}
}
func (m *MessageRpcHandleMultiReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcHandleMultiReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcHandleMultiReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcHandleMultiReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcHandleMultiReq.Merge(m, src)
}
func (m *MessageRpcHandleMultiReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcHandleMultiReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcHandleMultiReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcHandleMultiReq proto.InternalMessageInfo

func (m *MessageRpcHandleMultiReq) GetSendId() int64 {
	if m != nil {
		return m.SendId
	}
	return 0
}

func (m *MessageRpcHandleMultiReq) GetGroupIds() []int64 {
	if m != nil {
		return m.GroupIds
	}
	return nil
}

func (m *MessageRpcHandleMultiReq) GetImageUrls() []string {
	if m != nil {
		return m.ImageUrls
	}
	return nil
}

func (m *MessageRpcHandleMultiReq) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type MessageRpcHandleMultiResp struct {
	Result               bool     `protobuf:"varint,1,opt,name=result,proto3" json:"result"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcHandleMultiResp) Reset()         { *m = MessageRpcHandleMultiResp{} }
func (m *MessageRpcHandleMultiResp) String() string { return proto.CompactTextString(m) }
func (*MessageRpcHandleMultiResp) ProtoMessage()    {}
func (*MessageRpcHandleMultiResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{70}
}
func (m *MessageRpcHandleMultiResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcHandleMultiResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcHandleMultiResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcHandleMultiResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcHandleMultiResp.Merge(m, src)
}
func (m *MessageRpcHandleMultiResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcHandleMultiResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcHandleMultiResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcHandleMultiResp proto.InternalMessageInfo

func (m *MessageRpcHandleMultiResp) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type MessageRpcDelChatReq struct {
	UserId               int32    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	MapId                string   `protobuf:"bytes,2,opt,name=mapId,proto3" json:"mapId,omitempty" form:"mapId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcDelChatReq) Reset()         { *m = MessageRpcDelChatReq{} }
func (m *MessageRpcDelChatReq) String() string { return proto.CompactTextString(m) }
func (*MessageRpcDelChatReq) ProtoMessage()    {}
func (*MessageRpcDelChatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{71}
}
func (m *MessageRpcDelChatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcDelChatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcDelChatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcDelChatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcDelChatReq.Merge(m, src)
}
func (m *MessageRpcDelChatReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcDelChatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcDelChatReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcDelChatReq proto.InternalMessageInfo

func (m *MessageRpcDelChatReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MessageRpcDelChatReq) GetMapId() string {
	if m != nil {
		return m.MapId
	}
	return ""
}

type MessageAddToWhiteListReq struct {
	Users                []string `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty" form:"users"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageAddToWhiteListReq) Reset()         { *m = MessageAddToWhiteListReq{} }
func (m *MessageAddToWhiteListReq) String() string { return proto.CompactTextString(m) }
func (*MessageAddToWhiteListReq) ProtoMessage()    {}
func (*MessageAddToWhiteListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{72}
}
func (m *MessageAddToWhiteListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageAddToWhiteListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageAddToWhiteListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageAddToWhiteListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageAddToWhiteListReq.Merge(m, src)
}
func (m *MessageAddToWhiteListReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageAddToWhiteListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageAddToWhiteListReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageAddToWhiteListReq proto.InternalMessageInfo

func (m *MessageAddToWhiteListReq) GetUsers() []string {
	if m != nil {
		return m.Users
	}
	return nil
}

type MessageAddToWhiteListResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageAddToWhiteListResp) Reset()         { *m = MessageAddToWhiteListResp{} }
func (m *MessageAddToWhiteListResp) String() string { return proto.CompactTextString(m) }
func (*MessageAddToWhiteListResp) ProtoMessage()    {}
func (*MessageAddToWhiteListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{73}
}
func (m *MessageAddToWhiteListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageAddToWhiteListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageAddToWhiteListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageAddToWhiteListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageAddToWhiteListResp.Merge(m, src)
}
func (m *MessageAddToWhiteListResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageAddToWhiteListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageAddToWhiteListResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageAddToWhiteListResp proto.InternalMessageInfo

type MessageRpcListHistoryReq struct {
	// 当前用户id.
	FromId string `protobuf:"bytes,1,opt,name=fromId,proto3" json:"fromId,omitempty" form:"fromId"`
	// 当前用户类型
	FromRef string `protobuf:"bytes,2,opt,name=fromRef,proto3" json:"fromRef,omitempty" form:"fromRef"`
	// 会话方用户id
	ToId string `protobuf:"bytes,3,opt,name=toId,proto3" json:"toId,omitempty" form:"toId"`
	// 会话方用户类型
	ToRef string `protobuf:"bytes,4,opt,name=toRef,proto3" json:"toRef,omitempty" form:"toRef"`
	// 群组id.(如果传递该值，将忽略fromId,fromRef，toId,toRef)
	GroupId string `protobuf:"bytes,5,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	// 会话id。如果有值将忽略其他
	HashId string `protobuf:"bytes,6,opt,name=hashId,proto3" json:"hashId,omitempty" form:"hashId"`
	// 条数
	Start int32 `protobuf:"varint,7,opt,name=start,proto3" json:"start,omitempty" form:"start"`
	// 偏移量
	Limit int32 `protobuf:"varint,8,opt,name=limit,proto3" json:"limit,omitempty" form:"limit"`
	// 排序，1：倒序，0：正序
	Sort int32 `protobuf:"varint,9,opt,name=sort,proto3" json:"sort,omitempty" form:"sort"`
	// 开始时间戳
	StartTime int64 `protobuf:"varint,10,opt,name=startTime,proto3" json:"startTime,omitempty" form:"startTime"`
	// 结束时间戳
	EndTime              int64    `protobuf:"varint,11,opt,name=endTime,proto3" json:"endTime,omitempty" form:"endTime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcListHistoryReq) Reset()         { *m = MessageRpcListHistoryReq{} }
func (m *MessageRpcListHistoryReq) String() string { return proto.CompactTextString(m) }
func (*MessageRpcListHistoryReq) ProtoMessage()    {}
func (*MessageRpcListHistoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{74}
}
func (m *MessageRpcListHistoryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcListHistoryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcListHistoryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcListHistoryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcListHistoryReq.Merge(m, src)
}
func (m *MessageRpcListHistoryReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcListHistoryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcListHistoryReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcListHistoryReq proto.InternalMessageInfo

func (m *MessageRpcListHistoryReq) GetFromId() string {
	if m != nil {
		return m.FromId
	}
	return ""
}

func (m *MessageRpcListHistoryReq) GetFromRef() string {
	if m != nil {
		return m.FromRef
	}
	return ""
}

func (m *MessageRpcListHistoryReq) GetToId() string {
	if m != nil {
		return m.ToId
	}
	return ""
}

func (m *MessageRpcListHistoryReq) GetToRef() string {
	if m != nil {
		return m.ToRef
	}
	return ""
}

func (m *MessageRpcListHistoryReq) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *MessageRpcListHistoryReq) GetHashId() string {
	if m != nil {
		return m.HashId
	}
	return ""
}

func (m *MessageRpcListHistoryReq) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MessageRpcListHistoryReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *MessageRpcListHistoryReq) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *MessageRpcListHistoryReq) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MessageRpcListHistoryReq) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type MessageRpcListHistoryResp struct {
	Start                int32    `protobuf:"varint,1,opt,name=start,proto3" json:"start"`
	More                 bool     `protobuf:"varint,2,opt,name=more,proto3" json:"more"`
	Index                int64    `protobuf:"varint,3,opt,name=index,proto3" json:"index"`
	List                 []string `protobuf:"bytes,4,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcListHistoryResp) Reset()         { *m = MessageRpcListHistoryResp{} }
func (m *MessageRpcListHistoryResp) String() string { return proto.CompactTextString(m) }
func (*MessageRpcListHistoryResp) ProtoMessage()    {}
func (*MessageRpcListHistoryResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{75}
}
func (m *MessageRpcListHistoryResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcListHistoryResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcListHistoryResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcListHistoryResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcListHistoryResp.Merge(m, src)
}
func (m *MessageRpcListHistoryResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcListHistoryResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcListHistoryResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcListHistoryResp proto.InternalMessageInfo

func (m *MessageRpcListHistoryResp) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MessageRpcListHistoryResp) GetMore() bool {
	if m != nil {
		return m.More
	}
	return false
}

func (m *MessageRpcListHistoryResp) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MessageRpcListHistoryResp) GetList() []string {
	if m != nil {
		return m.List
	}
	return nil
}

type MessageRpcGetMessageHistoryReq struct {
	GroupId              string   `protobuf:"bytes,1,opt,name=groupId,proto3" json:"groupId,omitempty" form:"groupId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcGetMessageHistoryReq) Reset()         { *m = MessageRpcGetMessageHistoryReq{} }
func (m *MessageRpcGetMessageHistoryReq) String() string { return proto.CompactTextString(m) }
func (*MessageRpcGetMessageHistoryReq) ProtoMessage()    {}
func (*MessageRpcGetMessageHistoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{76}
}
func (m *MessageRpcGetMessageHistoryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcGetMessageHistoryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcGetMessageHistoryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcGetMessageHistoryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcGetMessageHistoryReq.Merge(m, src)
}
func (m *MessageRpcGetMessageHistoryReq) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcGetMessageHistoryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcGetMessageHistoryReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcGetMessageHistoryReq proto.InternalMessageInfo

func (m *MessageRpcGetMessageHistoryReq) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

type MessageRpcGetMessageHistoryResp struct {
	List                 []string `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcGetMessageHistoryResp) Reset()         { *m = MessageRpcGetMessageHistoryResp{} }
func (m *MessageRpcGetMessageHistoryResp) String() string { return proto.CompactTextString(m) }
func (*MessageRpcGetMessageHistoryResp) ProtoMessage()    {}
func (*MessageRpcGetMessageHistoryResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{77}
}
func (m *MessageRpcGetMessageHistoryResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcGetMessageHistoryResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcGetMessageHistoryResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcGetMessageHistoryResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcGetMessageHistoryResp.Merge(m, src)
}
func (m *MessageRpcGetMessageHistoryResp) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcGetMessageHistoryResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcGetMessageHistoryResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcGetMessageHistoryResp proto.InternalMessageInfo

func (m *MessageRpcGetMessageHistoryResp) GetList() []string {
	if m != nil {
		return m.List
	}
	return nil
}

type MessagePushNotifyOnlineReq struct {
	Data                 *SendSystemCols `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty" form:"data"`
	Reference            int32           `protobuf:"varint,2,opt,name=reference,proto3" json:"reference,omitempty" form:"reference"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MessagePushNotifyOnlineReq) Reset()         { *m = MessagePushNotifyOnlineReq{} }
func (m *MessagePushNotifyOnlineReq) String() string { return proto.CompactTextString(m) }
func (*MessagePushNotifyOnlineReq) ProtoMessage()    {}
func (*MessagePushNotifyOnlineReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{78}
}
func (m *MessagePushNotifyOnlineReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessagePushNotifyOnlineReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessagePushNotifyOnlineReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessagePushNotifyOnlineReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessagePushNotifyOnlineReq.Merge(m, src)
}
func (m *MessagePushNotifyOnlineReq) XXX_Size() int {
	return m.Size()
}
func (m *MessagePushNotifyOnlineReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessagePushNotifyOnlineReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessagePushNotifyOnlineReq proto.InternalMessageInfo

func (m *MessagePushNotifyOnlineReq) GetData() *SendSystemCols {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *MessagePushNotifyOnlineReq) GetReference() int32 {
	if m != nil {
		return m.Reference
	}
	return 0
}

type MessagePushNotifyOnlineResp struct {
	Data                 bool     `protobuf:"varint,1,opt,name=data,proto3" json:"data"`
	Errmsg               string   `protobuf:"bytes,2,opt,name=errmsg,proto3" json:"errmsg"`
	Errcode              int32    `protobuf:"varint,3,opt,name=errcode,proto3" json:"errcode"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessagePushNotifyOnlineResp) Reset()         { *m = MessagePushNotifyOnlineResp{} }
func (m *MessagePushNotifyOnlineResp) String() string { return proto.CompactTextString(m) }
func (*MessagePushNotifyOnlineResp) ProtoMessage()    {}
func (*MessagePushNotifyOnlineResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{79}
}
func (m *MessagePushNotifyOnlineResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessagePushNotifyOnlineResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessagePushNotifyOnlineResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessagePushNotifyOnlineResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessagePushNotifyOnlineResp.Merge(m, src)
}
func (m *MessagePushNotifyOnlineResp) XXX_Size() int {
	return m.Size()
}
func (m *MessagePushNotifyOnlineResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessagePushNotifyOnlineResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessagePushNotifyOnlineResp proto.InternalMessageInfo

func (m *MessagePushNotifyOnlineResp) GetData() bool {
	if m != nil {
		return m.Data
	}
	return false
}

func (m *MessagePushNotifyOnlineResp) GetErrmsg() string {
	if m != nil {
		return m.Errmsg
	}
	return ""
}

func (m *MessagePushNotifyOnlineResp) GetErrcode() int32 {
	if m != nil {
		return m.Errcode
	}
	return 0
}

type FetchPrescriptionMessageMarkReq struct {
	// userID
	UserId int64 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty" form:"userId"`
	// 批量用户ID 医生ids/患者ids
	OtherUserIds []int64 `protobuf:"varint,2,rep,packed,name=otherUserIds,proto3" json:"otherUserIds,omitempty" form:"otherUserIds"`
	// 批量groupID
	GroupIds             []int64  `protobuf:"varint,3,rep,packed,name=groupIds,proto3" json:"groupIds,omitempty" form:"groupIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchPrescriptionMessageMarkReq) Reset()         { *m = FetchPrescriptionMessageMarkReq{} }
func (m *FetchPrescriptionMessageMarkReq) String() string { return proto.CompactTextString(m) }
func (*FetchPrescriptionMessageMarkReq) ProtoMessage()    {}
func (*FetchPrescriptionMessageMarkReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{80}
}
func (m *FetchPrescriptionMessageMarkReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchPrescriptionMessageMarkReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchPrescriptionMessageMarkReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchPrescriptionMessageMarkReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchPrescriptionMessageMarkReq.Merge(m, src)
}
func (m *FetchPrescriptionMessageMarkReq) XXX_Size() int {
	return m.Size()
}
func (m *FetchPrescriptionMessageMarkReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchPrescriptionMessageMarkReq.DiscardUnknown(m)
}

var xxx_messageInfo_FetchPrescriptionMessageMarkReq proto.InternalMessageInfo

func (m *FetchPrescriptionMessageMarkReq) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *FetchPrescriptionMessageMarkReq) GetOtherUserIds() []int64 {
	if m != nil {
		return m.OtherUserIds
	}
	return nil
}

func (m *FetchPrescriptionMessageMarkReq) GetGroupIds() []int64 {
	if m != nil {
		return m.GroupIds
	}
	return nil
}

type FetchPrescriptionMessageMarkResp struct {
	RetMap               map[int64]int64 `protobuf:"bytes,1,rep,name=retMap,proto3" json:"retMap" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FetchPrescriptionMessageMarkResp) Reset()         { *m = FetchPrescriptionMessageMarkResp{} }
func (m *FetchPrescriptionMessageMarkResp) String() string { return proto.CompactTextString(m) }
func (*FetchPrescriptionMessageMarkResp) ProtoMessage()    {}
func (*FetchPrescriptionMessageMarkResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{81}
}
func (m *FetchPrescriptionMessageMarkResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchPrescriptionMessageMarkResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchPrescriptionMessageMarkResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchPrescriptionMessageMarkResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchPrescriptionMessageMarkResp.Merge(m, src)
}
func (m *FetchPrescriptionMessageMarkResp) XXX_Size() int {
	return m.Size()
}
func (m *FetchPrescriptionMessageMarkResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchPrescriptionMessageMarkResp.DiscardUnknown(m)
}

var xxx_messageInfo_FetchPrescriptionMessageMarkResp proto.InternalMessageInfo

func (m *FetchPrescriptionMessageMarkResp) GetRetMap() map[int64]int64 {
	if m != nil {
		return m.RetMap
	}
	return nil
}

type SendReq struct {
	Msg                  *entity.Message `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty" form:"msg"`
	ToUsers              []*misc.User    `protobuf:"bytes,2,rep,name=toUsers,proto3" json:"toUsers,omitempty" form:"toUsers"`
	IsSave               bool            `protobuf:"varint,3,opt,name=isSave,proto3" json:"isSave,omitempty" form:"isSave"`
	NeedPush             bool            `protobuf:"varint,4,opt,name=needPush,proto3" json:"needPush,omitempty" form:"needPush"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SendReq) Reset()         { *m = SendReq{} }
func (m *SendReq) String() string { return proto.CompactTextString(m) }
func (*SendReq) ProtoMessage()    {}
func (*SendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{82}
}
func (m *SendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendReq.Merge(m, src)
}
func (m *SendReq) XXX_Size() int {
	return m.Size()
}
func (m *SendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SendReq.DiscardUnknown(m)
}

var xxx_messageInfo_SendReq proto.InternalMessageInfo

func (m *SendReq) GetMsg() *entity.Message {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *SendReq) GetToUsers() []*misc.User {
	if m != nil {
		return m.ToUsers
	}
	return nil
}

func (m *SendReq) GetIsSave() bool {
	if m != nil {
		return m.IsSave
	}
	return false
}

func (m *SendReq) GetNeedPush() bool {
	if m != nil {
		return m.NeedPush
	}
	return false
}

type SendResp struct {
	// 发送成功的用户ids
	SucceedUids          []int64  `protobuf:"varint,1,rep,packed,name=succeedUids,proto3" json:"succeedUids,omitempty" form:"succeedUids"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendResp) Reset()         { *m = SendResp{} }
func (m *SendResp) String() string { return proto.CompactTextString(m) }
func (*SendResp) ProtoMessage()    {}
func (*SendResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{83}
}
func (m *SendResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendResp.Merge(m, src)
}
func (m *SendResp) XXX_Size() int {
	return m.Size()
}
func (m *SendResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SendResp.DiscardUnknown(m)
}

var xxx_messageInfo_SendResp proto.InternalMessageInfo

func (m *SendResp) GetSucceedUids() []int64 {
	if m != nil {
		return m.SucceedUids
	}
	return nil
}

type MessagePushSendReq struct {
	MsgStr               string   `protobuf:"bytes,1,opt,name=msgStr,proto3" json:"msgStr,omitempty" form:"msgStr"`
	ToUserStr            string   `protobuf:"bytes,2,opt,name=toUserStr,proto3" json:"toUserStr,omitempty" form:"toUserStr"`
	NeedSave             bool     `protobuf:"varint,3,opt,name=needSave,proto3" json:"needSave,omitempty" form:"needSave"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessagePushSendReq) Reset()         { *m = MessagePushSendReq{} }
func (m *MessagePushSendReq) String() string { return proto.CompactTextString(m) }
func (*MessagePushSendReq) ProtoMessage()    {}
func (*MessagePushSendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{84}
}
func (m *MessagePushSendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessagePushSendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessagePushSendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessagePushSendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessagePushSendReq.Merge(m, src)
}
func (m *MessagePushSendReq) XXX_Size() int {
	return m.Size()
}
func (m *MessagePushSendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MessagePushSendReq.DiscardUnknown(m)
}

var xxx_messageInfo_MessagePushSendReq proto.InternalMessageInfo

func (m *MessagePushSendReq) GetMsgStr() string {
	if m != nil {
		return m.MsgStr
	}
	return ""
}

func (m *MessagePushSendReq) GetToUserStr() string {
	if m != nil {
		return m.ToUserStr
	}
	return ""
}

func (m *MessagePushSendReq) GetNeedSave() bool {
	if m != nil {
		return m.NeedSave
	}
	return false
}

type MessagePushSendResp struct {
	Result               bool     `protobuf:"varint,1,opt,name=result,proto3" json:"result"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessagePushSendResp) Reset()         { *m = MessagePushSendResp{} }
func (m *MessagePushSendResp) String() string { return proto.CompactTextString(m) }
func (*MessagePushSendResp) ProtoMessage()    {}
func (*MessagePushSendResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{85}
}
func (m *MessagePushSendResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessagePushSendResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessagePushSendResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessagePushSendResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessagePushSendResp.Merge(m, src)
}
func (m *MessagePushSendResp) XXX_Size() int {
	return m.Size()
}
func (m *MessagePushSendResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessagePushSendResp.DiscardUnknown(m)
}

var xxx_messageInfo_MessagePushSendResp proto.InternalMessageInfo

func (m *MessagePushSendResp) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type MessageRpcHandleMulti2Req struct {
	ReqList              []*MessageRpcHandleReq `protobuf:"bytes,1,rep,name=reqList,proto3" json:"reqList,omitempty" form:"reqList"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *MessageRpcHandleMulti2Req) Reset()         { *m = MessageRpcHandleMulti2Req{} }
func (m *MessageRpcHandleMulti2Req) String() string { return proto.CompactTextString(m) }
func (*MessageRpcHandleMulti2Req) ProtoMessage()    {}
func (*MessageRpcHandleMulti2Req) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{86}
}
func (m *MessageRpcHandleMulti2Req) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcHandleMulti2Req) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcHandleMulti2Req.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcHandleMulti2Req) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcHandleMulti2Req.Merge(m, src)
}
func (m *MessageRpcHandleMulti2Req) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcHandleMulti2Req) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcHandleMulti2Req.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcHandleMulti2Req proto.InternalMessageInfo

func (m *MessageRpcHandleMulti2Req) GetReqList() []*MessageRpcHandleReq {
	if m != nil {
		return m.ReqList
	}
	return nil
}

type MessageRpcHandleMulti2Resp struct {
	Result               bool     `protobuf:"varint,1,opt,name=result,proto3" json:"result"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageRpcHandleMulti2Resp) Reset()         { *m = MessageRpcHandleMulti2Resp{} }
func (m *MessageRpcHandleMulti2Resp) String() string { return proto.CompactTextString(m) }
func (*MessageRpcHandleMulti2Resp) ProtoMessage()    {}
func (*MessageRpcHandleMulti2Resp) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7682c9c0757e08, []int{87}
}
func (m *MessageRpcHandleMulti2Resp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageRpcHandleMulti2Resp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageRpcHandleMulti2Resp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageRpcHandleMulti2Resp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageRpcHandleMulti2Resp.Merge(m, src)
}
func (m *MessageRpcHandleMulti2Resp) XXX_Size() int {
	return m.Size()
}
func (m *MessageRpcHandleMulti2Resp) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageRpcHandleMulti2Resp.DiscardUnknown(m)
}

var xxx_messageInfo_MessageRpcHandleMulti2Resp proto.InternalMessageInfo

func (m *MessageRpcHandleMulti2Resp) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func init() {
	proto.RegisterType((*UnreadReq)(nil), "med.xim.v1.UnreadReq")
	proto.RegisterType((*UnreadResp)(nil), "med.xim.v1.UnreadResp")
	proto.RegisterMapType((map[string]uint32)(nil), "med.xim.v1.UnreadResp.UnreadMapEntry")
	proto.RegisterType((*UnreadAllReq)(nil), "med.xim.v1.UnreadAllReq")
	proto.RegisterType((*UnreadAllResp)(nil), "med.xim.v1.UnreadAllResp")
	proto.RegisterMapType((map[string]uint32)(nil), "med.xim.v1.UnreadAllResp.UnreadAllMapEntry")
	proto.RegisterType((*UnreadBatchReq)(nil), "med.xim.v1.UnreadBatchReq")
	proto.RegisterType((*UnreadBatchResp)(nil), "med.xim.v1.UnreadBatchResp")
	proto.RegisterType((*UnreadBatch)(nil), "med.xim.v1.UnreadBatch")
	proto.RegisterType((*MarkLatestMsgReadReq)(nil), "med.xim.v1.MarkLatestMsgReadReq")
	proto.RegisterType((*MarkLatestMsgReadResp)(nil), "med.xim.v1.MarkLatestMsgReadResp")
	proto.RegisterType((*UnreadSweepV2Req)(nil), "med.xim.v1.UnreadSweepV2Req")
	proto.RegisterType((*UnreadSweepV2Resp)(nil), "med.xim.v1.UnreadSweepV2Resp")
	proto.RegisterType((*UnreadCountReq)(nil), "med.xim.v1.UnreadCountReq")
	proto.RegisterType((*UnreadCountResp)(nil), "med.xim.v1.UnreadCountResp")
	proto.RegisterMapType((map[string]uint32)(nil), "med.xim.v1.UnreadCountResp.UnreadCountMapEntry")
	proto.RegisterType((*ReadMarkReq)(nil), "med.xim.v1.ReadMarkReq")
	proto.RegisterType((*ReadMarkResp)(nil), "med.xim.v1.ReadMarkResp")
	proto.RegisterType((*UnreadInfoReq)(nil), "med.xim.v1.UnreadInfoReq")
	proto.RegisterType((*UnreadInfoResp)(nil), "med.xim.v1.UnreadInfoResp")
	proto.RegisterMapType((map[uint32]*UnreadMark)(nil), "med.xim.v1.UnreadInfoResp.UnreadInfoMapEntry")
	proto.RegisterType((*UnreadMark)(nil), "med.xim.v1.UnreadMark")
	proto.RegisterType((*UnreadSweepReq)(nil), "med.xim.v1.UnreadSweepReq")
	proto.RegisterType((*UnreadSweepResp)(nil), "med.xim.v1.UnreadSweepResp")
	proto.RegisterType((*UnreadPointReq)(nil), "med.xim.v1.UnreadPointReq")
	proto.RegisterType((*UnreadPointResp)(nil), "med.xim.v1.UnreadPointResp")
	proto.RegisterMapType((map[string]int32)(nil), "med.xim.v1.UnreadPointResp.RetMapEntry")
	proto.RegisterType((*AtUserReq)(nil), "med.xim.v1.AtUserReq")
	proto.RegisterType((*AtUserResp)(nil), "med.xim.v1.AtUserResp")
	proto.RegisterType((*ReadAtUserReq)(nil), "med.xim.v1.ReadAtUserReq")
	proto.RegisterType((*ReadAtUserResp)(nil), "med.xim.v1.ReadAtUserResp")
	proto.RegisterType((*FetchMessageAtUserReq)(nil), "med.xim.v1.FetchMessageAtUserReq")
	proto.RegisterType((*FetchMessageAtUserResp)(nil), "med.xim.v1.FetchMessageAtUserResp")
	proto.RegisterMapType((map[int32]int32)(nil), "med.xim.v1.FetchMessageAtUserResp.RetMapEntry")
	proto.RegisterType((*MarkMessageUnReadReq)(nil), "med.xim.v1.MarkMessageUnReadReq")
	proto.RegisterType((*MarkMessageUnReadResp)(nil), "med.xim.v1.MarkMessageUnReadResp")
	proto.RegisterType((*UnMarkMessageUnReadReq)(nil), "med.xim.v1.UnMarkMessageUnReadReq")
	proto.RegisterType((*UnMarkMessageUnReadResp)(nil), "med.xim.v1.UnMarkMessageUnReadResp")
	proto.RegisterType((*FetchMessageUnReadTotalReq)(nil), "med.xim.v1.FetchMessageUnReadTotalReq")
	proto.RegisterType((*FetchMessageUnReadTotalResp)(nil), "med.xim.v1.FetchMessageUnReadTotalResp")
	proto.RegisterMapType((map[int64]*FetchMessageUnReadTotal)(nil), "med.xim.v1.FetchMessageUnReadTotalResp.RetMapEntry")
	proto.RegisterType((*FetchMessageUnReadTotal)(nil), "med.xim.v1.FetchMessageUnReadTotal")
	proto.RegisterType((*MarkPrescriptionMessageReq)(nil), "med.xim.v1.MarkPrescriptionMessageReq")
	proto.RegisterType((*MarkPrescriptionMessageResp)(nil), "med.xim.v1.MarkPrescriptionMessageResp")
	proto.RegisterType((*UnMarkPrescriptionMessageReq)(nil), "med.xim.v1.UnMarkPrescriptionMessageReq")
	proto.RegisterType((*UnMarkPrescriptionMessageResp)(nil), "med.xim.v1.UnMarkPrescriptionMessageResp")
	proto.RegisterType((*MessageHandleReq)(nil), "med.xim.v1.MessageHandleReq")
	proto.RegisterType((*MessageHandleResp)(nil), "med.xim.v1.MessageHandleResp")
	proto.RegisterType((*MessageGetHistoryReq)(nil), "med.xim.v1.MessageGetHistoryReq")
	proto.RegisterType((*MessageGetHistoryResp)(nil), "med.xim.v1.MessageGetHistoryResp")
	proto.RegisterType((*MessageGetSysHistoryReq)(nil), "med.xim.v1.MessageGetSysHistoryReq")
	proto.RegisterType((*MessageGetSysHistoryResp)(nil), "med.xim.v1.MessageGetSysHistoryResp")
	proto.RegisterType((*MessageGetOfflineReq)(nil), "med.xim.v1.MessageGetOfflineReq")
	proto.RegisterType((*MessageGetOfflineResp)(nil), "med.xim.v1.MessageGetOfflineResp")
	proto.RegisterType((*MessageGetOfflineCountReq)(nil), "med.xim.v1.MessageGetOfflineCountReq")
	proto.RegisterType((*MessageGetOfflineCountResp)(nil), "med.xim.v1.MessageGetOfflineCountResp")
	proto.RegisterType((*MessageGetReceiptReq)(nil), "med.xim.v1.MessageGetReceiptReq")
	proto.RegisterType((*MessageGetReceiptResp)(nil), "med.xim.v1.MessageGetReceiptResp")
	proto.RegisterType((*MessageGetChatlistReq)(nil), "med.xim.v1.MessageGetChatlistReq")
	proto.RegisterType((*MessageGetChatlistResp)(nil), "med.xim.v1.MessageGetChatlistResp")
	proto.RegisterMapType((map[string]string)(nil), "med.xim.v1.MessageGetChatlistResp.DataEntry")
	proto.RegisterType((*MessageGetLocalReq)(nil), "med.xim.v1.MessageGetLocalReq")
	proto.RegisterType((*MessageGetLocalResp)(nil), "med.xim.v1.MessageGetLocalResp")
	proto.RegisterType((*MessageDelChatReq)(nil), "med.xim.v1.MessageDelChatReq")
	proto.RegisterType((*MessageDelChatResp)(nil), "med.xim.v1.MessageDelChatResp")
	proto.RegisterType((*MessageGetPatientChatListReq)(nil), "med.xim.v1.MessageGetPatientChatListReq")
	proto.RegisterType((*MessageGetPatientChatListResp)(nil), "med.xim.v1.MessageGetPatientChatListResp")
	proto.RegisterType((*GetPatientChatList)(nil), "med.xim.v1.GetPatientChatList")
	proto.RegisterType((*MessageGetImMenuReq)(nil), "med.xim.v1.MessageGetImMenuReq")
	proto.RegisterType((*MessageGetImMenuResp)(nil), "med.xim.v1.MessageGetImMenuResp")
	proto.RegisterType((*MenuFields)(nil), "med.xim.v1.MenuFields")
	proto.RegisterType((*MessageRpcSendSystemReq)(nil), "med.xim.v1.MessageRpcSendSystemReq")
	proto.RegisterType((*SendSystemCols)(nil), "med.xim.v1.SendSystemCols")
	proto.RegisterType((*Anchor)(nil), "med.xim.v1.Anchor")
	proto.RegisterType((*MessageRpcSendSystemResp)(nil), "med.xim.v1.MessageRpcSendSystemResp")
	proto.RegisterType((*MessageRpcHandleReq)(nil), "med.xim.v1.MessageRpcHandleReq")
	proto.RegisterType((*MessageRpcHandleResp)(nil), "med.xim.v1.MessageRpcHandleResp")
	proto.RegisterType((*MessageRpcHandleMultiReq)(nil), "med.xim.v1.MessageRpcHandleMultiReq")
	proto.RegisterType((*MessageRpcHandleMultiResp)(nil), "med.xim.v1.MessageRpcHandleMultiResp")
	proto.RegisterType((*MessageRpcDelChatReq)(nil), "med.xim.v1.MessageRpcDelChatReq")
	proto.RegisterType((*MessageAddToWhiteListReq)(nil), "med.xim.v1.MessageAddToWhiteListReq")
	proto.RegisterType((*MessageAddToWhiteListResp)(nil), "med.xim.v1.MessageAddToWhiteListResp")
	proto.RegisterType((*MessageRpcListHistoryReq)(nil), "med.xim.v1.MessageRpcListHistoryReq")
	proto.RegisterType((*MessageRpcListHistoryResp)(nil), "med.xim.v1.MessageRpcListHistoryResp")
	proto.RegisterType((*MessageRpcGetMessageHistoryReq)(nil), "med.xim.v1.MessageRpcGetMessageHistoryReq")
	proto.RegisterType((*MessageRpcGetMessageHistoryResp)(nil), "med.xim.v1.MessageRpcGetMessageHistoryResp")
	proto.RegisterType((*MessagePushNotifyOnlineReq)(nil), "med.xim.v1.MessagePushNotifyOnlineReq")
	proto.RegisterType((*MessagePushNotifyOnlineResp)(nil), "med.xim.v1.MessagePushNotifyOnlineResp")
	proto.RegisterType((*FetchPrescriptionMessageMarkReq)(nil), "med.xim.v1.FetchPrescriptionMessageMarkReq")
	proto.RegisterType((*FetchPrescriptionMessageMarkResp)(nil), "med.xim.v1.FetchPrescriptionMessageMarkResp")
	proto.RegisterMapType((map[int64]int64)(nil), "med.xim.v1.FetchPrescriptionMessageMarkResp.RetMapEntry")
	proto.RegisterType((*SendReq)(nil), "med.xim.v1.SendReq")
	proto.RegisterType((*SendResp)(nil), "med.xim.v1.SendResp")
	proto.RegisterType((*MessagePushSendReq)(nil), "med.xim.v1.MessagePushSendReq")
	proto.RegisterType((*MessagePushSendResp)(nil), "med.xim.v1.MessagePushSendResp")
	proto.RegisterType((*MessageRpcHandleMulti2Req)(nil), "med.xim.v1.MessageRpcHandleMulti2Req")
	proto.RegisterType((*MessageRpcHandleMulti2Resp)(nil), "med.xim.v1.MessageRpcHandleMulti2Resp")
}

func init() {
	proto.RegisterFile("med-common/app/service/med-xim/api/grpc/message.proto", fileDescriptor_5f7682c9c0757e08)
}

var fileDescriptor_5f7682c9c0757e08 = []byte{
	// 4554 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x3c, 0x4d, 0x6f, 0x1c, 0x47,
	0x76, 0xe8, 0x19, 0x0e, 0x39, 0x7c, 0xfc, 0x90, 0x54, 0xfa, 0xa2, 0x46, 0x1f, 0x43, 0x97, 0x56,
	0xb2, 0xb4, 0x96, 0x49, 0x48, 0x96, 0x60, 0xc9, 0x5e, 0xaf, 0x2c, 0xca, 0xb1, 0xad, 0xac, 0x28,
	0x0b, 0x25, 0xd1, 0x6b, 0xe4, 0xc3, 0xda, 0xd6, 0x4c, 0x71, 0xd8, 0xd6, 0x4c, 0x77, 0xb3, 0xab,
	0x87, 0x4b, 0x5e, 0x03, 0x64, 0xaf, 0xc1, 0x1e, 0x02, 0x67, 0x0f, 0xc9, 0x21, 0x08, 0x90, 0x00,
	0x39, 0x6d, 0x3e, 0x2e, 0x49, 0x80, 0x20, 0xc8, 0x65, 0x11, 0x20, 0x41, 0xb0, 0x87, 0x20, 0xa7,
	0x41, 0xe0, 0x5b, 0x78, 0x49, 0x40, 0xe4, 0x07, 0x04, 0xf5, 0xd9, 0x55, 0xdd, 0x3d, 0x5f, 0xde,
	0x0d, 0xd6, 0xb9, 0x70, 0xba, 0xdf, 0x7b, 0x55, 0xf5, 0xea, 0xbd, 0x57, 0xaf, 0x5e, 0xbd, 0x7a,
	0x4d, 0xb8, 0xd3, 0xa3, 0xed, 0x37, 0x5b, 0x51, 0xaf, 0x17, 0x85, 0xeb, 0x7e, 0x1c, 0xaf, 0x33,
	0x9a, 0xec, 0x05, 0x2d, 0xba, 0xce, 0xc1, 0xfb, 0x41, 0x6f, 0xdd, 0x8f, 0x83, 0xf5, 0x4e, 0x12,
	0xb7, 0xd6, 0x7b, 0x94, 0x31, 0xbf, 0x43, 0xd7, 0xe2, 0x24, 0x4a, 0x23, 0x04, 0x3d, 0xda, 0x5e,
	0xdb, 0x0f, 0x7a, 0x6b, 0x7b, 0x37, 0x1b, 0x6f, 0x76, 0x82, 0x74, 0xa7, 0xff, 0x72, 0xad, 0x15,
	0xf5, 0xd6, 0x3b, 0x51, 0x27, 0x5a, 0x17, 0x24, 0x2f, 0xfb, 0xdb, 0xe2, 0x4d, 0xbc, 0x88, 0x27,
	0xd9, 0xb4, 0xf1, 0xce, 0x04, 0x23, 0x06, 0xbd, 0x75, 0x1a, 0xa6, 0x41, 0x7a, 0xe0, 0x0e, 0xdb,
	0xf8, 0xce, 0x74, 0x6d, 0x03, 0xd6, 0x5a, 0xef, 0x33, 0x9a, 0xc8, 0xd6, 0xf8, 0x73, 0x98, 0xdf,
	0x0a, 0x13, 0xea, 0xb7, 0x09, 0xdd, 0x45, 0x57, 0xa1, 0xd6, 0xf3, 0xe3, 0x47, 0xed, 0x15, 0x6f,
	0xd5, 0xbb, 0x36, 0xbf, 0x71, 0xfc, 0x68, 0xd0, 0x5c, 0xdc, 0x8e, 0x92, 0xde, 0x3b, 0x58, 0x80,
	0x31, 0x91, 0x68, 0x74, 0x1d, 0x66, 0x79, 0x17, 0x8f, 0xda, 0x2b, 0x95, 0x55, 0xef, 0xda, 0xd2,
	0xc6, 0x89, 0xa3, 0x41, 0x73, 0x49, 0x12, 0x4a, 0x38, 0x26, 0x8a, 0x00, 0xff, 0x91, 0x07, 0xa0,
	0x07, 0x60, 0x31, 0x22, 0x30, 0xdf, 0x17, 0x6f, 0x9b, 0x7e, 0xbc, 0xe2, 0xad, 0x56, 0xaf, 0x2d,
	0xdc, 0xba, 0xb2, 0x96, 0xc9, 0x6d, 0x2d, 0x23, 0x55, 0x8f, 0x9b, 0x7e, 0xfc, 0x6b, 0x61, 0x9a,
	0x1c, 0x6c, 0x2c, 0x1d, 0x0e, 0x9a, 0x59, 0x5b, 0x92, 0x3d, 0x36, 0xbe, 0x03, 0xcb, 0x2e, 0x2d,
	0x3a, 0x0e, 0xd5, 0x57, 0xf4, 0x40, 0xce, 0x82, 0xf0, 0x47, 0x74, 0x0a, 0x6a, 0x7b, 0x7e, 0xb7,
	0x4f, 0x25, 0xc3, 0x44, 0xbe, 0xbc, 0x53, 0xb9, 0xeb, 0xe1, 0x7b, 0xb0, 0x28, 0x5b, 0x3f, 0xe8,
	0x76, 0xb9, 0x0c, 0xa6, 0x98, 0xdb, 0x5f, 0x7a, 0xb0, 0x64, 0xb5, 0x65, 0x31, 0xf2, 0x61, 0xb1,
	0xaf, 0x01, 0xd9, 0x0c, 0xdf, 0x28, 0xce, 0x50, 0x35, 0xc8, 0xde, 0xcc, 0x3c, 0x8f, 0x1f, 0x0e,
	0x9a, 0x4e, 0x27, 0xc4, 0x79, 0x6b, 0xdc, 0x87, 0x13, 0x85, 0x46, 0x53, 0x4d, 0xf8, 0x5d, 0x2d,
	0xae, 0x0d, 0x3f, 0x6d, 0xed, 0xa8, 0x29, 0x27, 0x74, 0xf7, 0x59, 0x9a, 0x28, 0xbd, 0x5b, 0x53,
	0x96, 0x70, 0x4c, 0x14, 0x01, 0x0e, 0xe0, 0x98, 0xd3, 0x98, 0xc5, 0xe8, 0x53, 0x38, 0xd6, 0xcf,
	0x40, 0x8f, 0x03, 0x96, 0xaa, 0x69, 0x9f, 0x2d, 0x4e, 0x5b, 0x90, 0x6c, 0x9c, 0x3c, 0x1c, 0x34,
	0xf3, 0x6d, 0x48, 0x1e, 0x80, 0xfb, 0xb0, 0x60, 0x35, 0x42, 0x97, 0x8d, 0x5e, 0x3c, 0xa1, 0x97,
	0x85, 0xc3, 0x41, 0x73, 0x8e, 0x43, 0x5e, 0x04, 0x6d, 0xad, 0x11, 0xb4, 0xaa, 0x0d, 0xb8, 0x22,
	0x26, 0x02, 0x87, 0x83, 0xe6, 0x6c, 0xcf, 0x8f, 0x39, 0x89, 0x32, 0xdd, 0x26, 0xd4, 0x5a, 0x51,
	0x3f, 0x4c, 0x57, 0xaa, 0xa2, 0x97, 0xf9, 0xc3, 0x41, 0x53, 0x02, 0x88, 0xfc, 0xc1, 0x3f, 0xf6,
	0xe0, 0xd4, 0xa6, 0x9f, 0xbc, 0x7a, 0xec, 0xa7, 0x94, 0xa5, 0x9b, 0xac, 0x43, 0xd4, 0xe2, 0xb8,
	0x9e, 0x63, 0x60, 0xb8, 0x61, 0x64, 0xeb, 0xa8, 0x32, 0x7a, 0x1d, 0x71, 0x3a, 0xd6, 0x79, 0xd4,
	0x16, 0xcc, 0xb8, 0x74, 0x1c, 0xcc, 0xe9, 0xc4, 0xef, 0x59, 0x38, 0x5d, 0xc2, 0x12, 0x8b, 0xf1,
	0x97, 0x1e, 0x1c, 0x97, 0x42, 0x7a, 0xf6, 0x43, 0x4a, 0xe3, 0x4f, 0x6f, 0x71, 0x46, 0x5f, 0x77,
	0x57, 0xb1, 0xc5, 0xa7, 0x14, 0xc5, 0xd7, 0x58, 0xc6, 0x68, 0x1d, 0xea, 0x2c, 0x08, 0x3b, 0x5d,
	0xaa, 0x98, 0x5d, 0xda, 0x38, 0x79, 0x34, 0x68, 0x1e, 0x93, 0xc4, 0x1a, 0x83, 0x89, 0x21, 0xc2,
	0x27, 0xb5, 0x99, 0x1a, 0xc6, 0x58, 0x8c, 0x3b, 0xda, 0xf4, 0x1e, 0x0a, 0x89, 0xd3, 0x5d, 0xf4,
	0x6d, 0x98, 0x15, 0xbc, 0x30, 0xc5, 0x2c, 0x3a, 0x1a, 0x34, 0x97, 0x6d, 0x66, 0x19, 0x26, 0x8a,
	0x62, 0x9a, 0x95, 0xf9, 0x0f, 0x9e, 0xb6, 0x53, 0x35, 0x12, 0x8b, 0xd1, 0x2b, 0x58, 0xee, 0x67,
	0xa0, 0x6c, 0x75, 0xae, 0x17, 0xcd, 0xd4, 0x34, 0xb2, 0xdf, 0xcd, 0x0a, 0x45, 0x87, 0x83, 0x66,
	0xae, 0x2b, 0x92, 0x7b, 0x6f, 0x3c, 0x80, 0x93, 0x25, 0x4d, 0xa7, 0x5a, 0xa7, 0xff, 0xe8, 0xc1,
	0x02, 0x11, 0x5e, 0x2d, 0x79, 0xc5, 0x45, 0x75, 0xd3, 0x56, 0x6b, 0x75, 0xe3, 0x7c, 0x66, 0xdb,
	0x43, 0x15, 0x7c, 0x53, 0xdb, 0x57, 0xc5, 0x6a, 0xc2, 0x3a, 0x6e, 0x13, 0xf1, 0xae, 0x4d, 0x0d,
	0x5d, 0x86, 0x99, 0xf4, 0x20, 0xa6, 0xca, 0x22, 0x8f, 0x1d, 0x0d, 0x9a, 0x0b, 0x92, 0x8e, 0x43,
	0x31, 0x11, 0x48, 0x4b, 0x13, 0x33, 0xe3, 0x34, 0xb1, 0x0c, 0x8b, 0xd9, 0x24, 0x58, 0x8c, 0x5b,
	0xda, 0x65, 0x3e, 0x0a, 0xb7, 0xa3, 0xff, 0x23, 0x6b, 0xc5, 0x3f, 0xf7, 0xb4, 0xa1, 0xc9, 0x51,
	0x58, 0x8c, 0xb6, 0x61, 0xa9, 0x6f, 0x20, 0x99, 0xf2, 0xdf, 0x2c, 0x2a, 0x5f, 0x37, 0xb1, 0x5e,
	0x8d, 0xea, 0x4f, 0x1c, 0x0e, 0x9a, 0x6e, 0x3f, 0xc4, 0x7d, 0x6d, 0x7c, 0x06, 0xa8, 0xd8, 0xce,
	0xd6, 0xfb, 0x92, 0xd4, 0xfb, 0x0d, 0x5b, 0xef, 0x0b, 0xb7, 0xce, 0x14, 0xf9, 0x10, 0x22, 0xb3,
	0xec, 0xe1, 0x2f, 0xcc, 0x4e, 0xca, 0x31, 0xe8, 0x2a, 0xcc, 0x75, 0x92, 0xa8, 0x1f, 0x1b, 0x7f,
	0xb4, 0x78, 0x38, 0x68, 0xd6, 0x05, 0x88, 0xbb, 0x3b, 0x8d, 0x14, 0x2e, 0xd1, 0xd8, 0x80, 0x76,
	0x89, 0x42, 0xe7, 0x99, 0xca, 0xb5, 0x60, 0xab, 0xc3, 0x3d, 0xeb, 0x1d, 0x58, 0xe4, 0x4f, 0x4f,
	0xbb, 0x7e, 0xca, 0x65, 0x2e, 0x14, 0x3f, 0xaf, 0xe4, 0xc1, 0x49, 0x63, 0x85, 0x20, 0x0e, 0x19,
	0xfe, 0x81, 0x56, 0x84, 0x70, 0x03, 0x5c, 0xdf, 0xab, 0x50, 0xed, 0x07, 0xda, 0x88, 0x97, 0x8f,
	0x06, 0x4d, 0x50, 0x3a, 0xe4, 0xaa, 0xe6, 0x28, 0x74, 0x23, 0x9b, 0x59, 0x25, 0xef, 0x14, 0x14,
	0x02, 0x9b, 0xf9, 0xe1, 0x3b, 0x7a, 0xa5, 0xab, 0x11, 0x58, 0x8c, 0x30, 0xcc, 0xb2, 0xd4, 0x4f,
	0xfb, 0xd2, 0xa9, 0xd4, 0xe4, 0x9c, 0x25, 0x84, 0xa8, 0x5f, 0xfc, 0xdb, 0x9a, 0xb1, 0xa7, 0x51,
	0x20, 0x5d, 0xd1, 0x78, 0xc6, 0xae, 0x1b, 0x67, 0x55, 0x59, 0xad, 0x16, 0x6c, 0xf5, 0x91, 0xe5,
	0xab, 0xf0, 0x4f, 0x8c, 0x03, 0x52, 0xfd, 0xb3, 0x18, 0x7d, 0x8f, 0x6f, 0xb3, 0x96, 0xe3, 0x79,
	0xbd, 0xa8, 0x73, 0x43, 0xbc, 0x46, 0x68, 0xe6, 0x70, 0x04, 0xff, 0xb2, 0x29, 0x51, 0xbf, 0x8d,
	0x7b, 0xdc, 0x39, 0x4c, 0xec, 0x58, 0x6a, 0xb6, 0x21, 0xfd, 0xdc, 0x83, 0xf9, 0x07, 0xe9, 0x16,
	0xa3, 0x09, 0x9f, 0xf6, 0x3a, 0xd4, 0xdb, 0x51, 0x2b, 0x8d, 0xf4, 0xc6, 0x56, 0xb3, 0x3d, 0xbb,
	0xc6, 0x60, 0x62, 0x88, 0xd0, 0x2d, 0x98, 0x8f, 0xfd, 0x34, 0xa0, 0x61, 0xaa, 0x14, 0x54, 0xdb,
	0x38, 0x75, 0x34, 0x68, 0x1e, 0x97, 0x2d, 0x0c, 0x0a, 0x93, 0x8c, 0x8c, 0xb7, 0xf1, 0xc5, 0x88,
	0x5c, 0x78, 0xd5, 0xd5, 0xaa, 0xdb, 0xc6, 0xa0, 0x30, 0xc9, 0xc8, 0x6c, 0x33, 0x98, 0x11, 0xa3,
	0x8c, 0x34, 0x83, 0x45, 0x00, 0x3d, 0x27, 0x16, 0xe3, 0x3f, 0xf6, 0x60, 0x89, 0xbb, 0x9d, 0x6c,
	0x9a, 0xee, 0xee, 0x5d, 0x1b, 0xb5, 0xd7, 0xdd, 0x85, 0x85, 0x28, 0xdd, 0xa1, 0xc9, 0x56, 0xe6,
	0x6d, 0x6a, 0x1b, 0x67, 0x8e, 0x06, 0x4d, 0x24, 0xe9, 0x2d, 0x24, 0x26, 0x36, 0xa9, 0xcd, 0x72,
	0x75, 0x3c, 0xcb, 0xc7, 0x61, 0xd9, 0xe6, 0x91, 0xc5, 0x78, 0x0f, 0x4e, 0x7f, 0x48, 0xd3, 0xd6,
	0xce, 0xa6, 0x0c, 0xf0, 0x33, 0xee, 0x2d, 0xdb, 0xac, 0x95, 0xdb, 0xe6, 0xbb, 0xb0, 0x68, 0x71,
	0x22, 0x2d, 0xb4, 0xb6, 0x71, 0xf6, 0x68, 0xd0, 0x3c, 0x59, 0xe0, 0x9a, 0x61, 0xe2, 0x10, 0xe3,
	0x3f, 0xf5, 0xe0, 0x4c, 0xd9, 0xc0, 0x22, 0x60, 0x77, 0x8d, 0x76, 0xcd, 0x36, 0xda, 0xf2, 0x36,
	0xbf, 0x80, 0xed, 0xd6, 0xc6, 0xd9, 0xee, 0xef, 0xce, 0xc8, 0xe8, 0x4c, 0x0d, 0xba, 0x15, 0xea,
	0xe8, 0xec, 0x2e, 0x2c, 0xf8, 0x8c, 0x05, 0x2c, 0xf5, 0x85, 0x5d, 0xca, 0x55, 0x6c, 0x29, 0xcd,
	0x42, 0x62, 0x62, 0x93, 0x72, 0xc9, 0xed, 0x50, 0xbf, 0x9b, 0xee, 0xf4, 0xfc, 0x50, 0x4b, 0xae,
	0x6a, 0x4b, 0xce, 0xc6, 0x62, 0xe2, 0x10, 0x3b, 0xab, 0xa7, 0x2a, 0xc6, 0x9c, 0x66, 0xf5, 0xcc,
	0x88, 0x16, 0x63, 0x57, 0x8f, 0x65, 0x56, 0x35, 0xd1, 0x62, 0x94, 0x59, 0xf1, 0x11, 0xd4, 0x01,
	0xf1, 0x51, 0x7b, 0x65, 0x36, 0x3f, 0x82, 0x41, 0x61, 0x92, 0x91, 0xa1, 0x3b, 0x00, 0xdb, 0x49,
	0xd4, 0x53, 0x16, 0x3f, 0x27, 0x1a, 0x9d, 0x3e, 0x1a, 0x34, 0x4f, 0xc8, 0x46, 0x19, 0x0e, 0x13,
	0x8b, 0x90, 0x8b, 0x4e, 0xbf, 0x91, 0xa8, 0x4b, 0x57, 0xea, 0xc2, 0x5d, 0x5b, 0xa2, 0xb3, 0xb1,
	0x98, 0x38, 0xc4, 0x05, 0x8b, 0x9d, 0xcf, 0xcb, 0x7d, 0x94, 0xc5, 0xaa, 0x88, 0x38, 0x67, 0x06,
	0x2c, 0xc6, 0x7f, 0xee, 0xc1, 0x99, 0xad, 0xb0, 0xd4, 0x44, 0x5c, 0x17, 0x50, 0x9d, 0xd2, 0x05,
	0x54, 0xbf, 0x96, 0x0b, 0x18, 0xad, 0x2b, 0x7c, 0x0e, 0xce, 0x96, 0x32, 0xcb, 0x62, 0xfc, 0xd7,
	0x1e, 0x34, 0xec, 0xf5, 0x25, 0x51, 0xcf, 0xa3, 0xd4, 0xef, 0x4e, 0x39, 0x99, 0x32, 0xd7, 0x30,
	0xa9, 0xa0, 0xb9, 0x81, 0x2b, 0x66, 0xa5, 0xe3, 0x76, 0x0c, 0x5c, 0x63, 0x30, 0x31, 0x44, 0xf8,
	0xdf, 0x3c, 0x38, 0x3f, 0x94, 0x6f, 0x16, 0xa3, 0xef, 0xe7, 0x1c, 0xca, 0x5b, 0xc3, 0x1c, 0x4a,
	0xae, 0xe1, 0x58, 0xaf, 0xf2, 0xf9, 0x50, 0xaf, 0x52, 0x95, 0x5e, 0xe5, 0x9e, 0x1b, 0x72, 0x5d,
	0x9e, 0x64, 0x60, 0xcb, 0xf5, 0xfc, 0x5e, 0x05, 0xce, 0x0e, 0x21, 0x43, 0x8f, 0xe1, 0x94, 0x5c,
	0xe1, 0x9b, 0xac, 0x23, 0x77, 0x72, 0x01, 0x57, 0xba, 0x59, 0x39, 0x1c, 0x34, 0x4b, 0xf1, 0xa4,
	0x14, 0x8a, 0x3e, 0x81, 0xd3, 0x6a, 0xf1, 0xe7, 0xba, 0x93, 0x76, 0x78, 0xee, 0x70, 0xd0, 0x2c,
	0x27, 0x20, 0xe5, 0x60, 0xb4, 0x05, 0x67, 0x8d, 0xc7, 0xcb, 0x75, 0x59, 0x35, 0x27, 0x83, 0x61,
	0x24, 0x64, 0x18, 0x02, 0xff, 0xac, 0x02, 0x0d, 0x6e, 0xbc, 0x4f, 0x13, 0xca, 0x5a, 0x49, 0x10,
	0xa7, 0x41, 0x14, 0x2a, 0xe1, 0x70, 0x13, 0xbd, 0x01, 0x73, 0x7d, 0x65, 0x72, 0x9e, 0xb0, 0x1c,
	0x6b, 0x29, 0xf4, 0xb5, 0xb5, 0x69, 0x12, 0xc7, 0x93, 0x56, 0xa6, 0xf6, 0xa4, 0xd5, 0xa9, 0x3d,
	0xe9, 0xcc, 0x94, 0x9e, 0xb4, 0xf6, 0x75, 0x3c, 0xe9, 0xec, 0x84, 0x9e, 0x14, 0x5f, 0x84, 0xf3,
	0x43, 0x25, 0xc9, 0x62, 0xfc, 0x53, 0x0f, 0x2e, 0x48, 0x47, 0x31, 0x44, 0xd6, 0xdf, 0x40, 0xdf,
	0xd6, 0x84, 0x8b, 0x23, 0x58, 0x66, 0x31, 0xfe, 0x2f, 0x0f, 0x8e, 0xab, 0xf7, 0x8f, 0xfd, 0xb0,
	0xdd, 0x15, 0x13, 0xb9, 0x02, 0xb5, 0x56, 0x37, 0x78, 0xb1, 0x57, 0x4c, 0x41, 0x0a, 0x30, 0x26,
	0x33, 0xad, 0x6e, 0xf0, 0x29, 0x27, 0x63, 0x07, 0xec, 0x45, 0x5c, 0xcc, 0xb0, 0x08, 0x30, 0x26,
	0x33, 0xec, 0x80, 0x3d, 0x45, 0xb7, 0x01, 0xf6, 0xcd, 0xd1, 0x44, 0x9d, 0x69, 0x2d, 0x6d, 0x64,
	0x38, 0x4c, 0xe6, 0xf7, 0xf5, 0xa1, 0x85, 0xcf, 0xb3, 0x15, 0x85, 0x29, 0x0d, 0x53, 0x75, 0xcc,
	0xb1, 0xe6, 0xa9, 0x10, 0x98, 0x68, 0x12, 0x4b, 0xf4, 0xb5, 0x31, 0x91, 0x25, 0xfe, 0x27, 0x0f,
	0x4e, 0xe4, 0x66, 0xcc, 0x62, 0xd4, 0xd4, 0x27, 0x34, 0xa9, 0x3a, 0x91, 0x92, 0x12, 0x00, 0x7d,
	0x40, 0xbb, 0x00, 0x33, 0x41, 0xb8, 0x1d, 0xa9, 0xb9, 0xd6, 0x0f, 0x07, 0x4d, 0xf1, 0x4e, 0xc4,
	0x5f, 0x74, 0x0d, 0xea, 0x82, 0xec, 0x59, 0x9a, 0xa8, 0x19, 0x8a, 0x93, 0xa0, 0x86, 0x11, 0xf3,
	0x84, 0xae, 0xc0, 0x5c, 0xb4, 0xbd, 0xdd, 0x0d, 0x42, 0xba, 0x32, 0x23, 0x16, 0xa4, 0x38, 0xe9,
	0x29, 0x10, 0xd1, 0x0f, 0x9c, 0xcc, 0x0e, 0x37, 0x6a, 0x92, 0x4c, 0x81, 0x32, 0xfd, 0xfe, 0x4b,
	0x15, 0x4e, 0xa9, 0xc9, 0x7c, 0x44, 0xd3, 0x8f, 0x03, 0x96, 0x46, 0xc9, 0x01, 0x57, 0xe1, 0x65,
	0x98, 0x49, 0x23, 0x13, 0x68, 0xdb, 0x29, 0x84, 0x88, 0x0b, 0x43, 0x20, 0xd1, 0x55, 0xa8, 0xa5,
	0x11, 0xa1, 0xdb, 0x2a, 0xbc, 0xb6, 0x14, 0x28, 0xc0, 0x98, 0x48, 0x34, 0x97, 0xee, 0x8e, 0xcf,
	0x76, 0x4c, 0x44, 0x6d, 0x49, 0x57, 0xc2, 0x31, 0x51, 0x04, 0xd3, 0x1d, 0x18, 0x38, 0x03, 0xdd,
	0xa0, 0x17, 0xa4, 0x6a, 0x8e, 0x16, 0x03, 0x02, 0x8c, 0x89, 0x44, 0x73, 0xba, 0x97, 0xb4, 0x13,
	0x84, 0x6a, 0x2d, 0x5b, 0x74, 0x02, 0x8c, 0x89, 0x44, 0xf3, 0x10, 0x9d, 0x86, 0x3a, 0x76, 0xb2,
	0x42, 0x74, 0x1a, 0xf2, 0x10, 0x9d, 0x86, 0x62, 0x44, 0x96, 0xfa, 0x49, 0x2a, 0xc2, 0x24, 0x67,
	0x44, 0x01, 0xc6, 0x44, 0xa2, 0xb9, 0xfc, 0x58, 0x94, 0xa4, 0x2b, 0xf3, 0x79, 0xf9, 0x71, 0x28,
	0xb7, 0xec, 0x28, 0x11, 0x6c, 0x05, 0x61, 0x9b, 0xee, 0xaf, 0x40, 0x7e, 0x01, 0x08, 0x30, 0x26,
	0x12, 0x6d, 0x59, 0xe7, 0xc2, 0x38, 0xeb, 0xfc, 0x7d, 0x0f, 0x4e, 0x97, 0x28, 0x54, 0x5a, 0xa8,
	0xe4, 0x5c, 0xaa, 0x54, 0x58, 0xa8, 0x00, 0x68, 0x96, 0x2f, 0xc0, 0x4c, 0x2f, 0x4a, 0xe4, 0xce,
	0x5a, 0x97, 0x16, 0xca, 0xdf, 0x89, 0xf8, 0xcb, 0x9b, 0x4b, 0x5e, 0xab, 0x99, 0x81, 0x0b, 0x80,
	0x66, 0xf2, 0x02, 0xcc, 0x74, 0x03, 0x96, 0x0a, 0xab, 0x54, 0x06, 0xce, 0xdf, 0x89, 0xf8, 0x8b,
	0xff, 0xde, 0x83, 0xb3, 0x19, 0x5f, 0xcf, 0x0e, 0x98, 0x65, 0x6b, 0xd7, 0x61, 0x36, 0x89, 0x44,
	0x56, 0xb2, 0x70, 0xac, 0x93, 0x70, 0x4c, 0x14, 0x41, 0xa6, 0xf0, 0xca, 0x58, 0x85, 0xcb, 0xc9,
	0x56, 0x47, 0xab, 0xc9, 0x4d, 0x82, 0x8d, 0x94, 0xec, 0x1f, 0x78, 0xb0, 0x52, 0x3e, 0x83, 0x5f,
	0xb9, 0x70, 0x1f, 0xd8, 0x8b, 0xf8, 0x13, 0xe5, 0x0a, 0xa6, 0x3a, 0x2f, 0xe3, 0x3b, 0xb6, 0xd9,
	0x98, 0x2e, 0x58, 0x6c, 0x46, 0xf6, 0x4a, 0x47, 0xfe, 0x10, 0xce, 0x15, 0x9a, 0x99, 0xbc, 0xf0,
	0x14, 0xc3, 0xbf, 0x07, 0x8d, 0x61, 0xfd, 0x48, 0xe9, 0xca, 0x7c, 0xbf, 0x25, 0x5d, 0x27, 0xdf,
	0xff, 0x03, 0x5b, 0x00, 0x84, 0xb6, 0x68, 0x10, 0x0b, 0x0e, 0x2e, 0x42, 0xc5, 0x64, 0x83, 0x96,
	0x8e, 0x06, 0xcd, 0x79, 0xb5, 0xba, 0xda, 0x98, 0x54, 0x82, 0x7c, 0x36, 0x72, 0x24, 0x83, 0x67,
	0x6d, 0xf9, 0x98, 0x11, 0x58, 0x8c, 0x37, 0x6c, 0xc4, 0xc3, 0x1d, 0x3f, 0x15, 0xd2, 0x99, 0x6e,
	0xf6, 0x7f, 0xe8, 0xc1, 0x99, 0xb2, 0x4e, 0x58, 0x8c, 0x7e, 0x1d, 0x66, 0xda, 0x7e, 0xea, 0xab,
	0x38, 0xfb, 0x86, 0x1d, 0xee, 0x96, 0xb7, 0x58, 0xfb, 0xc0, 0x4f, 0x7d, 0x19, 0x60, 0x0b, 0x65,
	0xf1, 0xd6, 0x44, 0xfc, 0x6d, 0xbc, 0x0d, 0xf3, 0x06, 0x39, 0x2e, 0xd9, 0x34, 0x6f, 0x47, 0xcd,
	0x7f, 0xe5, 0x01, 0xca, 0x46, 0x7b, 0x1c, 0xb5, 0xe4, 0xf1, 0x65, 0xd5, 0xea, 0xc2, 0xf6, 0x96,
	0xaf, 0xe8, 0x01, 0x96, 0x5d, 0x5e, 0x75, 0xba, 0xb4, 0x97, 0xa1, 0x00, 0x63, 0x35, 0x88, 0x25,
	0xab, 0xea, 0xb8, 0xc4, 0xce, 0x75, 0x98, 0xed, 0xd1, 0x74, 0x27, 0x6a, 0xeb, 0xec, 0xa5, 0x95,
	0xbf, 0x13, 0x70, 0x4c, 0x14, 0x01, 0x7e, 0x0b, 0x4e, 0x16, 0xb8, 0x96, 0x16, 0xad, 0x44, 0x6a,
	0x76, 0xe2, 0x4c, 0x48, 0xf8, 0xcb, 0x8a, 0xd9, 0xde, 0x3f, 0xa0, 0x5d, 0x2e, 0xd9, 0x29, 0x33,
	0x4f, 0xef, 0xc2, 0x62, 0xea, 0x27, 0x1d, 0x9a, 0x3a, 0xa9, 0x27, 0xeb, 0xa4, 0x66, 0x63, 0x31,
	0x71, 0x88, 0xd1, 0x77, 0x61, 0x29, 0x7b, 0xe7, 0x3b, 0xab, 0x94, 0xc7, 0xca, 0xd1, 0xa0, 0x79,
	0x2a, 0xdf, 0x5a, 0xec, 0xb0, 0x2e, 0xf9, 0x94, 0xdb, 0xe7, 0x0d, 0x98, 0xeb, 0xf9, 0xf1, 0xf7,
	0xe8, 0x01, 0x13, 0x1b, 0x68, 0xfe, 0xe6, 0x86, 0x23, 0x30, 0xd1, 0x24, 0xf8, 0x94, 0x31, 0x02,
	0x23, 0x18, 0x16, 0xe3, 0x47, 0x70, 0x21, 0x13, 0xf2, 0x53, 0x19, 0xa4, 0x73, 0xe4, 0xe3, 0xe9,
	0x97, 0x41, 0x00, 0x17, 0x47, 0x74, 0xc5, 0x62, 0xf4, 0x31, 0xd4, 0x5b, 0xea, 0x5d, 0x2d, 0x88,
	0x4b, 0xf6, 0x82, 0x28, 0xb6, 0x92, 0x51, 0x94, 0x6e, 0x43, 0xcc, 0x13, 0xfe, 0xb2, 0x0a, 0xa8,
	0x48, 0x2e, 0xa2, 0x38, 0xeb, 0x1e, 0x43, 0x46, 0x71, 0x1c, 0xa0, 0xef, 0x2f, 0xae, 0xc0, 0x9c,
	0x3a, 0x26, 0x28, 0x93, 0x16, 0x61, 0x95, 0x02, 0x11, 0xfd, 0xc0, 0xc3, 0x39, 0x27, 0xa3, 0x54,
	0x93, 0x8c, 0x68, 0x98, 0x75, 0x00, 0x5a, 0x03, 0x90, 0xcf, 0x4f, 0xfc, 0x1e, 0x55, 0x26, 0xbd,
	0x7c, 0x38, 0x68, 0x5a, 0x50, 0x62, 0x3d, 0xa3, 0xdb, 0xb0, 0x28, 0xdf, 0x1e, 0xec, 0xf9, 0xa9,
	0x9f, 0x28, 0xbd, 0x89, 0xfb, 0x66, 0x1b, 0x4e, 0x9c, 0x37, 0x74, 0xd3, 0x4d, 0xac, 0xcd, 0xca,
	0xa0, 0xe4, 0x70, 0xd0, 0xb4, 0xc1, 0x6e, 0x46, 0xed, 0x6d, 0x58, 0x32, 0xaf, 0x82, 0xb7, 0xb9,
	0xec, 0xb2, 0xc0, 0x41, 0x10, 0xf7, 0x15, 0xbd, 0x07, 0xc7, 0x0c, 0x40, 0x31, 0x29, 0x53, 0x4a,
	0xe2, 0xc6, 0x38, 0x87, 0x22, 0x79, 0x00, 0xfe, 0xd1, 0x8c, 0xbd, 0x6a, 0x1f, 0xf5, 0x36, 0x69,
	0xd8, 0xd7, 0x01, 0xe9, 0x41, 0x4c, 0x4b, 0x02, 0x52, 0xeb, 0x4e, 0xeb, 0x36, 0x40, 0x12, 0xbe,
	0xd8, 0xa3, 0x09, 0x0b, 0xa2, 0x50, 0xad, 0x3c, 0xeb, 0xa8, 0x90, 0xe1, 0x30, 0x99, 0x4f, 0xc2,
	0x4f, 0xe5, 0x33, 0x6f, 0x15, 0xee, 0x99, 0x56, 0xd5, 0x7c, 0xab, 0x0c, 0x87, 0xc9, 0x7c, 0xb8,
	0xa7, 0x5b, 0xad, 0x81, 0xb9, 0xa8, 0x51, 0x6b, 0x2d, 0x9f, 0x54, 0x11, 0x17, 0x5f, 0xce, 0x41,
	0xd4, 0x9c, 0x62, 0xa4, 0xda, 0xec, 0x83, 0xa8, 0x75, 0x88, 0x31, 0xcf, 0xe8, 0x3e, 0x2c, 0xb7,
	0x03, 0x46, 0x7d, 0x46, 0x5f, 0xa4, 0x7e, 0x87, 0x8f, 0x24, 0x55, 0x77, 0xee, 0x68, 0xd0, 0x3c,
	0xad, 0x4e, 0xd5, 0x0e, 0x1e, 0x93, 0x45, 0x05, 0x78, 0xee, 0x77, 0xc4, 0xe5, 0xe1, 0xbc, 0x34,
	0x04, 0xde, 0x76, 0x2e, 0x9f, 0xe7, 0x37, 0x28, 0xfb, 0x48, 0x7e, 0x1b, 0x40, 0x9d, 0xb5, 0x79,
	0x9b, 0x7a, 0x5e, 0x1a, 0x19, 0xce, 0x39, 0x94, 0x67, 0xcb, 0x7c, 0x7e, 0x9c, 0x83, 0x34, 0xa7,
	0x43, 0x18, 0x75, 0x3a, 0xc4, 0x8f, 0xed, 0x3d, 0x5d, 0xdb, 0x01, 0x8b, 0xd1, 0x6d, 0x2b, 0x20,
	0xc9, 0xdd, 0xb9, 0x71, 0x9a, 0x0f, 0x03, 0xda, 0x6d, 0xb3, 0x42, 0xa0, 0xf2, 0x77, 0x55, 0x80,
	0x0c, 0xcd, 0xf7, 0x80, 0xf8, 0x95, 0xf1, 0x49, 0x82, 0x98, 0xbf, 0x13, 0xf1, 0x17, 0x9d, 0x11,
	0x61, 0x83, 0x34, 0x9f, 0xd9, 0xc3, 0x41, 0xb3, 0x12, 0xb4, 0x45, 0xbc, 0xd0, 0x84, 0x5a, 0x1a,
	0xa4, 0x5d, 0x7d, 0xb1, 0x2a, 0xdc, 0x83, 0x00, 0x10, 0xf9, 0xc3, 0xbb, 0x15, 0x46, 0x3a, 0x93,
	0x75, 0xcb, 0xdf, 0x95, 0x75, 0x5e, 0x83, 0xfa, 0x17, 0xfd, 0x5e, 0xfc, 0x9c, 0x53, 0xd4, 0x32,
	0xaf, 0xa0, 0x61, 0xc4, 0x3c, 0x71, 0xaf, 0xd0, 0x0b, 0xb4, 0x7d, 0x2a, 0x9d, 0x0b, 0xaf, 0x90,
	0x41, 0x89, 0xf5, 0x2c, 0xe8, 0xfd, 0x7d, 0x4d, 0x3f, 0x67, 0xd1, 0x1b, 0x28, 0xb1, 0x9e, 0xc5,
	0x61, 0xb4, 0x15, 0x85, 0x6a, 0x61, 0xca, 0xc3, 0x68, 0x2b, 0x0a, 0x89, 0xf8, 0xcb, 0x9d, 0x1c,
	0xe7, 0x64, 0x2b, 0xe9, 0x0a, 0x65, 0x2a, 0x27, 0xa7, 0x40, 0x44, 0x3f, 0x88, 0xa8, 0x6c, 0x87,
	0xb6, 0x5e, 0x09, 0x3d, 0xea, 0xa8, 0x8c, 0x03, 0x88, 0xfc, 0xe1, 0xa3, 0x88, 0x33, 0xd0, 0x42,
	0x26, 0x0d, 0xfe, 0xae, 0x0e, 0x3f, 0x6f, 0xd8, 0xeb, 0x61, 0x51, 0x8c, 0x23, 0xca, 0x83, 0x0c,
	0xd0, 0x5a, 0x08, 0xf8, 0xcf, 0x2a, 0xe6, 0xf8, 0x40, 0xe2, 0xd6, 0x33, 0x1a, 0xb6, 0x9f, 0x1d,
	0xb0, 0x94, 0xf6, 0xf2, 0x9e, 0x61, 0xe8, 0x6d, 0xb7, 0x95, 0xc7, 0x92, 0xb7, 0x2a, 0x23, 0xf3,
	0x58, 0xf7, 0x61, 0xa6, 0x15, 0x75, 0x99, 0xd0, 0xf3, 0xc2, 0xad, 0x86, 0x6d, 0x63, 0xd9, 0xd8,
	0x0f, 0xa3, 0x2e, 0xb3, 0x87, 0xe3, 0x2d, 0xb8, 0xf1, 0x46, 0x5d, 0x91, 0x08, 0x63, 0x34, 0x6c,
	0x5b, 0x27, 0x0b, 0xbb, 0xd4, 0x42, 0x61, 0x30, 0x31, 0x44, 0x3c, 0x52, 0x6a, 0xd3, 0xae, 0x7f,
	0x20, 0x0c, 0xa3, 0x6e, 0x2f, 0x0a, 0x01, 0xc6, 0x44, 0xa2, 0xc5, 0x09, 0x75, 0x3f, 0x15, 0x26,
	0xe1, 0xc4, 0x5c, 0x74, 0x3f, 0xe5, 0x27, 0xd4, 0xfd, 0x14, 0xff, 0x4f, 0x15, 0x96, 0x5d, 0x26,
	0x27, 0xf3, 0x9d, 0x56, 0xc2, 0xa4, 0x32, 0x3e, 0x61, 0xf2, 0x3e, 0xcc, 0xf9, 0x61, 0x6b, 0x27,
	0x4a, 0x64, 0x46, 0x79, 0xe1, 0x16, 0xb2, 0x85, 0xf4, 0x40, 0xa0, 0xec, 0x1e, 0x14, 0x31, 0x26,
	0xba, 0x99, 0x38, 0xca, 0xf9, 0x2f, 0x69, 0x57, 0x6d, 0x7a, 0xf6, 0x51, 0x8e, 0x83, 0xf9, 0x51,
	0x8e, 0xff, 0x8a, 0x24, 0x83, 0x58, 0x74, 0xb5, 0x3c, 0x9d, 0x00, 0x63, 0xbd, 0xf6, 0xb8, 0xc8,
	0xfb, 0x2f, 0x25, 0xa9, 0x14, 0x8f, 0x2d, 0x72, 0x85, 0xe1, 0x22, 0x57, 0x8f, 0x7c, 0xc2, 0xac,
	0xdf, 0xeb, 0xf9, 0xc9, 0x81, 0xda, 0xdb, 0x2c, 0x76, 0x15, 0x02, 0x13, 0x4d, 0x22, 0xce, 0xea,
	0x3d, 0xbe, 0xef, 0xd7, 0x0b, 0x67, 0x75, 0x0e, 0xe6, 0x67, 0x75, 0xfe, 0x2b, 0x6e, 0xf9, 0xcc,
	0xc2, 0xb1, 0x6f, 0xf9, 0x92, 0x2e, 0x26, 0x1c, 0xc5, 0xc7, 0x6d, 0x07, 0x2c, 0xe6, 0xca, 0x86,
	0x7c, 0x8c, 0xa6, 0x10, 0x98, 0x68, 0x12, 0x3e, 0x2e, 0xdd, 0x4f, 0x13, 0x5f, 0xac, 0x22, 0x67,
	0x5c, 0x01, 0xc6, 0x44, 0xa2, 0xf1, 0x0f, 0x61, 0x56, 0x4a, 0x9d, 0x6b, 0x7b, 0x27, 0xa1, 0xdb,
	0xc5, 0xf5, 0xc0, 0xa1, 0x98, 0x08, 0x64, 0x76, 0x40, 0xae, 0x8c, 0x3e, 0x20, 0xaf, 0x42, 0xb5,
	0x4b, 0xf5, 0xa6, 0x68, 0x4d, 0xa7, 0x4b, 0x43, 0x4c, 0x38, 0x0a, 0x7f, 0xd7, 0x1c, 0x8b, 0x73,
	0x2b, 0x53, 0x5e, 0xe2, 0x27, 0x94, 0xf5, 0xbb, 0xf2, 0xe4, 0x56, 0xd7, 0x29, 0x7f, 0x0e, 0x21,
	0xea, 0x17, 0xff, 0xd4, 0x33, 0x1b, 0x3e, 0x89, 0x5b, 0x59, 0x12, 0xf1, 0xb2, 0x13, 0xa6, 0x5b,
	0xd3, 0x10, 0x61, 0xba, 0x8c, 0xd6, 0xf9, 0xa6, 0xba, 0x9d, 0x44, 0xbd, 0xa7, 0x49, 0xb4, 0x7f,
	0xa0, 0xce, 0xd6, 0xd6, 0xfe, 0x66, 0x50, 0x98, 0x64, 0x64, 0xe8, 0x01, 0x2c, 0x07, 0xec, 0x49,
	0x94, 0x3e, 0xa1, 0xb4, 0x4d, 0xa2, 0x7e, 0x28, 0x43, 0xb4, 0xba, 0xbd, 0xa9, 0xba, 0x78, 0x4c,
	0x72, 0x0d, 0xf0, 0x3f, 0x7b, 0x66, 0x73, 0xb2, 0x78, 0xfe, 0xff, 0x9b, 0x06, 0xfc, 0x77, 0xcf,
	0x56, 0xa2, 0x9c, 0xcf, 0x66, 0xbf, 0x9b, 0x06, 0x2a, 0x82, 0xe7, 0x6e, 0xaa, 0x2c, 0x2d, 0x2d,
	0xe1, 0x98, 0x28, 0x02, 0xe7, 0xa2, 0xa9, 0x32, 0xc1, 0x45, 0x13, 0xd7, 0x9f, 0x58, 0x36, 0x5b,
	0x49, 0x57, 0x3a, 0x12, 0x27, 0x28, 0x32, 0x28, 0x4c, 0x32, 0xb2, 0xe9, 0x32, 0xbb, 0xf8, 0xbe,
	0xc9, 0x50, 0xe4, 0x67, 0x36, 0xa1, 0x7d, 0x06, 0xb6, 0xaa, 0xbf, 0xde, 0x91, 0x70, 0xc2, 0x52,
	0x42, 0xbc, 0x61, 0xb4, 0xf0, 0xa0, 0xdd, 0x7e, 0x1e, 0x7d, 0x7f, 0x27, 0x48, 0xa9, 0x3e, 0x47,
	0x5d, 0x85, 0x1a, 0xef, 0x8d, 0xa9, 0x44, 0x8c, 0xd5, 0x87, 0x00, 0x63, 0x22, 0xd1, 0xf8, 0xbc,
	0x99, 0x6f, 0xbe, 0x0f, 0x16, 0xe3, 0xff, 0xae, 0xda, 0x7a, 0xe6, 0x60, 0x37, 0x0d, 0xc7, 0x17,
	0x49, 0x59, 0x15, 0x97, 0x84, 0x63, 0xa2, 0x08, 0xb8, 0x0a, 0xf8, 0x93, 0x4e, 0xfd, 0x3a, 0x2a,
	0x50, 0x08, 0x4c, 0x34, 0x89, 0xc9, 0x25, 0x17, 0xcb, 0xd1, 0xca, 0x72, 0xc9, 0x85, 0xed, 0xc0,
	0xcd, 0x25, 0xe7, 0xee, 0xd1, 0x47, 0x17, 0x16, 0x59, 0x99, 0xe7, 0xd9, 0xfc, 0x9c, 0xf2, 0x99,
	0x67, 0xe3, 0x11, 0xe7, 0x46, 0x7b, 0x44, 0x93, 0x82, 0xac, 0x8f, 0x4e, 0x41, 0x4e, 0x94, 0x01,
	0xbe, 0x05, 0xf3, 0xa2, 0xd7, 0xe7, 0x41, 0x8f, 0x8a, 0xdd, 0xc0, 0xb9, 0x9d, 0x32, 0x28, 0x4c,
	0x32, 0x32, 0x2e, 0x01, 0x1a, 0xb6, 0x45, 0x8b, 0x85, 0xfc, 0x0d, 0x8e, 0x42, 0x60, 0xa2, 0x49,
	0xf0, 0x4f, 0x3c, 0x7b, 0x01, 0x38, 0x2a, 0xff, 0x95, 0xe7, 0x2d, 0x9f, 0xc0, 0xa5, 0x8c, 0xb5,
	0x8f, 0x68, 0xaa, 0xaf, 0x55, 0x32, 0x9b, 0xbc, 0xe1, 0x16, 0xc8, 0x8d, 0x29, 0x23, 0xbb, 0x0f,
	0xcd, 0x91, 0xfd, 0x8d, 0x4d, 0x67, 0xfe, 0xd8, 0x33, 0x79, 0xc8, 0xa7, 0x7d, 0xb6, 0xf3, 0x24,
	0x4a, 0x83, 0xed, 0x83, 0x4f, 0x42, 0x9d, 0x4f, 0xbd, 0x6f, 0x6d, 0x49, 0x13, 0x87, 0x85, 0xb9,
	0xed, 0x2a, 0xa1, 0xdb, 0x34, 0xa1, 0x61, 0x8b, 0x16, 0xcb, 0xae, 0x0c, 0x8a, 0x9f, 0x4e, 0xcd,
	0xf3, 0x8f, 0x3c, 0x38, 0x3f, 0x94, 0xa7, 0x5c, 0x3a, 0xab, 0x9e, 0x4f, 0x67, 0x71, 0x0f, 0x47,
	0x93, 0xa4, 0xc7, 0x3a, 0x76, 0xe9, 0xa0, 0x84, 0x10, 0xf5, 0xcb, 0x37, 0x09, 0x9a, 0x24, 0xad,
	0xa8, 0x4d, 0xd5, 0x3e, 0x2f, 0x36, 0x09, 0x05, 0x22, 0xfa, 0x01, 0xff, 0x8d, 0x07, 0x4d, 0x71,
	0x77, 0x5e, 0x72, 0x17, 0xa8, 0xeb, 0x5b, 0xbf, 0xb1, 0x15, 0x0d, 0x7f, 0xeb, 0xc1, 0xea, 0x68,
	0xe6, 0x59, 0x8c, 0x7e, 0x2b, 0x57, 0xd6, 0x70, 0xb7, 0x50, 0x5d, 0x30, 0xa2, 0xf5, 0x2f, 0x50,
	0x31, 0x55, 0x2d, 0x49, 0xc0, 0x56, 0xed, 0x04, 0xec, 0x7f, 0x7a, 0x30, 0xc7, 0x2d, 0x8c, 0x8b,
	0xf8, 0x1e, 0x54, 0xb9, 0x3a, 0xa5, 0x0d, 0x66, 0xe5, 0xf9, 0xf2, 0xd3, 0x10, 0x9d, 0x14, 0xb6,
	0x43, 0xb5, 0x1e, 0xeb, 0x60, 0xc2, 0xdb, 0xa0, 0x8f, 0x60, 0x2e, 0x8d, 0xb6, 0xc4, 0x2e, 0x52,
	0x11, 0x13, 0x3c, 0x97, 0x6f, 0xde, 0x0b, 0x58, 0x6b, 0x8d, 0x53, 0xd8, 0x0b, 0x4d, 0xb5, 0xc1,
	0x44, 0xb7, 0xe6, 0x6a, 0x0e, 0xd8, 0x33, 0x7f, 0x8f, 0xaa, 0xd0, 0xc9, 0x52, 0xb3, 0x84, 0x63,
	0xa2, 0x08, 0xb8, 0xa6, 0x42, 0x4a, 0xdb, 0xdc, 0x74, 0x85, 0x6b, 0xaf, 0xdb, 0x9a, 0xd2, 0x18,
	0x4c, 0x0c, 0x11, 0xfe, 0x00, 0xea, 0x72, 0xaa, 0x2c, 0x46, 0x77, 0x61, 0x81, 0xf5, 0x5b, 0x2d,
	0x4a, 0xdb, 0x5b, 0x81, 0xa9, 0x40, 0xb0, 0xae, 0xb9, 0x2d, 0x24, 0x26, 0x36, 0x29, 0xfe, 0x93,
	0x2c, 0x65, 0xcd, 0x7b, 0xd5, 0xc2, 0xbb, 0x0e, 0xb3, 0x3d, 0xd6, 0x29, 0xfd, 0x4a, 0x42, 0xc2,
	0x31, 0x51, 0x04, 0x7c, 0xad, 0xca, 0xe9, 0x72, 0xea, 0x4a, 0x3e, 0x5f, 0x63, 0x50, 0x98, 0x64,
	0x64, 0x7a, 0xb2, 0x96, 0x64, 0x72, 0x93, 0x95, 0xb2, 0x31, 0x44, 0xf8, 0x9e, 0x89, 0x7d, 0x33,
	0x2e, 0x27, 0x8c, 0x4b, 0xbe, 0x18, 0x12, 0xd8, 0x88, 0xcf, 0x07, 0x36, 0x61, 0x2e, 0xa1, 0xbb,
	0x56, 0xa2, 0xb4, 0x59, 0x72, 0x73, 0x60, 0x87, 0xdb, 0xb6, 0xbe, 0x55, 0x4b, 0x4c, 0x74, 0x1f,
	0xf8, 0x7d, 0xe3, 0x16, 0x0b, 0x63, 0x4d, 0xc6, 0xed, 0xad, 0xdf, 0xb9, 0x04, 0x73, 0xaa, 0x0b,
	0xf4, 0x36, 0xcc, 0xca, 0x0a, 0x14, 0x74, 0xba, 0xec, 0xb3, 0xa1, 0xdd, 0xc6, 0x99, 0xf2, 0xaf,
	0x89, 0xd0, 0xfb, 0xfa, 0x3b, 0xa7, 0x07, 0xdd, 0x2e, 0x5a, 0x19, 0xf2, 0x41, 0xce, 0x6e, 0xe3,
	0xdc, 0xd0, 0x4f, 0x75, 0xd0, 0x87, 0xee, 0xf7, 0x28, 0x8d, 0x21, 0x5f, 0xb7, 0xf0, 0x5e, 0xce,
	0x0f, 0xc5, 0xb1, 0x18, 0x7d, 0x06, 0x27, 0x0a, 0x1f, 0x73, 0xa0, 0x55, 0x47, 0xc6, 0x25, 0x9f,
	0x9f, 0x34, 0x5e, 0x1b, 0x43, 0xc1, 0x62, 0xf4, 0x58, 0xd7, 0xd6, 0xab, 0x6f, 0x2e, 0xd0, 0x85,
	0x22, 0x1f, 0xd9, 0x77, 0x22, 0x8d, 0x8b, 0x23, 0xb0, 0xf6, 0x7c, 0xc5, 0x65, 0x5a, 0xd9, 0x7c,
	0xf5, 0x6d, 0x5d, 0xd9, 0x7c, 0xb3, 0x1b, 0xb8, 0xf7, 0xa0, 0xae, 0xbf, 0x00, 0x40, 0xce, 0x27,
	0x41, 0xd6, 0xc7, 0x0d, 0x8d, 0x95, 0x72, 0x04, 0x8b, 0xd1, 0x43, 0x5d, 0xf5, 0xfe, 0x88, 0x9f,
	0x72, 0xce, 0x0d, 0xab, 0xd7, 0xdf, 0x6d, 0x34, 0x86, 0x97, 0xf2, 0xf3, 0xb9, 0xf4, 0xb3, 0x09,
	0x96, 0xcd, 0x45, 0xd7, 0xa7, 0x97, 0xcd, 0x25, 0xab, 0x2c, 0x37, 0xfd, 0x88, 0x42, 0xed, 0xb2,
	0x7e, 0x74, 0x39, 0x79, 0x59, 0x3f, 0x59, 0x29, 0xf8, 0xdb, 0x30, 0x2b, 0xeb, 0x65, 0x5d, 0x33,
	0x36, 0x05, 0xbf, 0xae, 0x19, 0x5b, 0xe5, 0xb8, 0x0f, 0x01, 0x12, 0x53, 0x33, 0xec, 0x4a, 0xc3,
	0xa9, 0x77, 0x76, 0xa5, 0xe1, 0x96, 0x19, 0xa3, 0xdf, 0x04, 0x54, 0xac, 0xdc, 0x45, 0xaf, 0x8d,
	0xab, 0xec, 0xdd, 0x6d, 0xe0, 0xf1, 0xc5, 0xbf, 0xda, 0xbc, 0x9d, 0x22, 0xb9, 0xa2, 0x79, 0xe7,
	0x8b, 0x33, 0x8b, 0xe6, 0x5d, 0xa8, 0x88, 0x44, 0x9f, 0xc3, 0xc9, 0x92, 0x62, 0x49, 0x84, 0x5d,
	0x41, 0x97, 0xf6, 0x7e, 0x79, 0x2c, 0x0d, 0x8b, 0xd1, 0x17, 0xc3, 0xeb, 0xfb, 0xae, 0x4e, 0x54,
	0xa4, 0xb8, 0xdb, 0x78, 0x7d, 0xc2, 0x62, 0x46, 0x3e, 0xd6, 0x90, 0xd2, 0x28, 0x77, 0xac, 0xe1,
	0x25, 0x5f, 0xee, 0x58, 0x23, 0xea, 0xac, 0x50, 0x0c, 0xe7, 0x86, 0x16, 0x62, 0xa1, 0x6b, 0x45,
	0xc9, 0x0c, 0x19, 0xef, 0xfa, 0x84, 0x94, 0x2c, 0x46, 0x07, 0x70, 0x61, 0x54, 0xc8, 0x83, 0xde,
	0x98, 0x3c, 0x38, 0xda, 0x6d, 0xdc, 0x98, 0x26, 0x92, 0xe2, 0x3e, 0xd0, 0xa9, 0xb0, 0x72, 0x7d,
	0x60, 0xbe, 0xdc, 0xcc, 0xf5, 0x81, 0xc5, 0xd2, 0xac, 0xd8, 0xae, 0x51, 0xc8, 0xdf, 0xf8, 0x5d,
	0x2b, 0xbf, 0x51, 0x2f, 0x5e, 0x64, 0xba, 0xa2, 0x1b, 0x7d, 0x4f, 0xf9, 0x99, 0xb9, 0x42, 0xce,
	0x6a, 0x70, 0x72, 0xcb, 0xa7, 0xa4, 0xe6, 0x2a, 0xb7, 0x7c, 0x4a, 0x8b, 0x78, 0x7c, 0xfb, 0x52,
	0x24, 0xab, 0x41, 0x41, 0x97, 0xcb, 0x9b, 0x3a, 0x75, 0x36, 0x8d, 0x6f, 0x8d, 0x27, 0xca, 0x33,
	0xaf, 0x4a, 0x31, 0x86, 0x31, 0x9f, 0xd5, 0x9a, 0x0c, 0x63, 0xde, 0x2e, 0x25, 0xe9, 0xd8, 0x55,
	0x0e, 0x76, 0x91, 0x07, 0xba, 0x32, 0xb2, 0xb1, 0xd9, 0xa2, 0xae, 0x4e, 0x42, 0x96, 0x9f, 0x82,
	0x2a, 0xd6, 0x18, 0x36, 0x85, 0xac, 0x5a, 0x64, 0xd8, 0x14, 0xac, 0x6a, 0x0f, 0xee, 0x75, 0x8b,
	0x65, 0x17, 0xe8, 0xb5, 0x71, 0x65, 0x19, 0x39, 0xaf, 0x3b, 0xa4, 0xd6, 0x83, 0xc0, 0xb1, 0x5c,
	0xbd, 0x02, 0xba, 0x54, 0xde, 0x4c, 0x97, 0x60, 0x34, 0x9a, 0x23, 0xf1, 0x2c, 0x46, 0x9f, 0xc0,
	0xb2, 0x7b, 0x69, 0x8f, 0xca, 0x56, 0x4b, 0x96, 0xd6, 0x6a, 0x5c, 0x1a, 0x85, 0x66, 0x31, 0xda,
	0x32, 0xf5, 0x9e, 0xe6, 0x5a, 0x0e, 0x0d, 0xe1, 0xc2, 0x5c, 0xde, 0x36, 0x56, 0x47, 0x13, 0x38,
	0x86, 0xed, 0x64, 0x91, 0x4b, 0x0d, 0x3b, 0x7f, 0x03, 0x54, 0x6a, 0xd8, 0xc5, 0x64, 0x74, 0x60,
	0x2a, 0x15, 0x14, 0x6e, 0xa3, 0xcf, 0x82, 0x90, 0x32, 0x26, 0x8f, 0xd4, 0xbf, 0xcc, 0xa1, 0xfc,
	0x62, 0x7a, 0xf8, 0xb9, 0xcf, 0x5e, 0xfd, 0x32, 0x87, 0xc8, 0xf4, 0x60, 0x86, 0x40, 0xe3, 0x82,
	0xfc, 0x52, 0x3d, 0xb8, 0x09, 0xec, 0xb6, 0x29, 0x67, 0x72, 0x23, 0x7d, 0xf4, 0xad, 0x51, 0x4d,
	0x75, 0xae, 0xb8, 0x71, 0x65, 0x02, 0x2a, 0xc1, 0xfc, 0x89, 0x42, 0x4e, 0x15, 0x0d, 0x61, 0x6e,
	0x0a, 0xdb, 0xcc, 0x98, 0x77, 0x73, 0x9f, 0xa5, 0xcc, 0x17, 0x52, 0xac, 0xa5, 0xcc, 0x17, 0x93,
	0xa8, 0xae, 0x88, 0xac, 0x84, 0xda, 0x30, 0x11, 0xb9, 0x69, 0xd6, 0x61, 0x22, 0xca, 0x67, 0xe6,
	0xf6, 0x4c, 0xd6, 0xa7, 0x2c, 0x97, 0x85, 0xbe, 0x5d, 0xde, 0x4b, 0x59, 0x12, 0xad, 0xf1, 0xc6,
	0xc4, 0xb4, 0x2a, 0xa8, 0x29, 0xcf, 0x36, 0xa1, 0x32, 0xf7, 0x5b, 0x92, 0x26, 0xcb, 0x05, 0x35,
	0x23, 0x52, 0x57, 0x37, 0x61, 0x86, 0x5b, 0x35, 0x3a, 0x99, 0xcf, 0xa4, 0xf1, 0x5e, 0x4e, 0x15,
	0x81, 0x8e, 0x8f, 0xd4, 0x07, 0xe6, 0x52, 0x1f, 0x69, 0x9d, 0xf9, 0x4b, 0x7d, 0xa4, 0x73, 0xda,
	0xce, 0xf6, 0xa5, 0xdc, 0xe9, 0x16, 0x8d, 0x37, 0xe7, 0x5b, 0xc3, 0xf6, 0xa5, 0x92, 0x83, 0xf2,
	0xc6, 0x89, 0x9f, 0x7d, 0x75, 0xc9, 0xfb, 0xd7, 0xaf, 0x2e, 0x79, 0xff, 0xf1, 0xd5, 0x25, 0xef,
	0x37, 0xaa, 0xfb, 0x41, 0xef, 0xe5, 0xac, 0xf8, 0x0f, 0x1e, 0x6f, 0xfd, 0x6f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x68, 0xce, 0x0b, 0x12, 0xaf, 0x44, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MessageClient is the client API for Message service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MessageClient interface {
	// 获取指定用户指定会话的消息未读数
	Unread(ctx context.Context, in *UnreadReq, opts ...grpc.CallOption) (*UnreadResp, error)
	// 获取指定用户的所有会话的消息未读数
	UnreadAll(ctx context.Context, in *UnreadAllReq, opts ...grpc.CallOption) (*UnreadAllResp, error)
	// 批量读取用户指定会话的消息未读数
	UnreadBatch(ctx context.Context, in *UnreadBatchReq, opts ...grpc.CallOption) (*UnreadBatchResp, error)
	// 标记消息已读
	MarkLatestMsgRead(ctx context.Context, in *MarkLatestMsgReadReq, opts ...grpc.CallOption) (*MarkLatestMsgReadResp, error)
	// 清除指定会话的消息未读数
	UnreadSweepV2(ctx context.Context, in *UnreadSweepV2Req, opts ...grpc.CallOption) (*UnreadSweepV2Resp, error)
	// 消息未读数的接口
	UnreadCount(ctx context.Context, in *UnreadCountReq, opts ...grpc.CallOption) (*UnreadCountResp, error)
	// 标记会话的最新msgId已读
	ReadMark(ctx context.Context, in *ReadMarkReq, opts ...grpc.CallOption) (*ReadMarkResp, error)
	// 获取会话未读标记
	UnreadInfo(ctx context.Context, in *UnreadInfoReq, opts ...grpc.CallOption) (*UnreadInfoResp, error)
	//清除指定会话的消息未读数
	UnreadSweep(ctx context.Context, in *UnreadSweepReq, opts ...grpc.CallOption) (*UnreadSweepResp, error)
	//批量获取未读数
	UnreadPoint(ctx context.Context, in *UnreadPointReq, opts ...grpc.CallOption) (*UnreadPointResp, error)
	// @me
	AtUser(ctx context.Context, in *AtUserReq, opts ...grpc.CallOption) (*AtUserResp, error)
	// 读取@me
	ReadAtUser(ctx context.Context, in *ReadAtUserReq, opts ...grpc.CallOption) (*ReadAtUserResp, error)
	// 批量获取用户@消息
	FetchMessageAtUser(ctx context.Context, in *FetchMessageAtUserReq, opts ...grpc.CallOption) (*FetchMessageAtUserResp, error)
	// 设置未读消息数（医生|患者 消息）
	MarkMessageUnRead(ctx context.Context, in *MarkMessageUnReadReq, opts ...grpc.CallOption) (*MarkMessageUnReadResp, error)
	// 取消设置新处方消息
	UnMarkMessageUnRead(ctx context.Context, in *UnMarkMessageUnReadReq, opts ...grpc.CallOption) (*UnMarkMessageUnReadResp, error)
	// 批量获取用户未读消息数（医生|患者 消息）
	FetchMessageUnReadTotal(ctx context.Context, in *FetchMessageUnReadTotalReq, opts ...grpc.CallOption) (*FetchMessageUnReadTotalResp, error)
	// 设置新处方消息
	MarkPrescriptionMessage(ctx context.Context, in *MarkPrescriptionMessageReq, opts ...grpc.CallOption) (*MarkPrescriptionMessageResp, error)
	// 取消设置新处方消息
	UnMarkPrescriptionMessage(ctx context.Context, in *UnMarkPrescriptionMessageReq, opts ...grpc.CallOption) (*UnMarkPrescriptionMessageResp, error)
	// 批量获取用户处方消息标记
	FetchPrescriptionMessageMark(ctx context.Context, in *FetchPrescriptionMessageMarkReq, opts ...grpc.CallOption) (*FetchPrescriptionMessageMarkResp, error)
	// 发送消息
	MessageHandle(ctx context.Context, in *MessageHandleReq, opts ...grpc.CallOption) (*MessageHandleResp, error)
	// 患者端会话列表
	MessageGetPatientChatList(ctx context.Context, in *MessageGetPatientChatListReq, opts ...grpc.CallOption) (*MessageGetPatientChatListResp, error)
	//消息历史记录
	MessageGetHistory(ctx context.Context, in *MessageGetHistoryReq, opts ...grpc.CallOption) (*MessageGetHistoryResp, error)
	//系统消息历史记录
	MessageGetSysHistory(ctx context.Context, in *MessageGetSysHistoryReq, opts ...grpc.CallOption) (*MessageGetSysHistoryResp, error)
	//离线消息
	MessageGetOffline(ctx context.Context, in *MessageGetOfflineReq, opts ...grpc.CallOption) (*MessageGetOfflineResp, error)
	// 离线消息数量
	MessageGetOfflineCount(ctx context.Context, in *MessageGetOfflineCountReq, opts ...grpc.CallOption) (*MessageGetOfflineCountResp, error)
	//消息回执
	MessageGetReceipt(ctx context.Context, in *MessageGetReceiptReq, opts ...grpc.CallOption) (*MessageGetReceiptResp, error)
	//会话列表
	MessageGetChatlist(ctx context.Context, in *MessageGetChatlistReq, opts ...grpc.CallOption) (*MessageGetChatlistResp, error)
	//本地存储代理
	MessageGetLocal(ctx context.Context, in *MessageGetLocalReq, opts ...grpc.CallOption) (*MessageGetLocalResp, error)
	//删除会话 批量
	MessageDelChat(ctx context.Context, in *MessageDelChatReq, opts ...grpc.CallOption) (*MessageDelChatResp, error)
	// 获取动态菜单
	MessageGetImMenu(ctx context.Context, in *MessageGetImMenuReq, opts ...grpc.CallOption) (*MessageGetImMenuResp, error)
	//jsonrpc
	// 发系统消息
	MessageRpcSendSystem(ctx context.Context, in *MessageRpcSendSystemReq, opts ...grpc.CallOption) (*MessageRpcSendSystemResp, error)
	// 发送企业通知
	MessageRpcSendBusinessNotify(ctx context.Context, in *MessageRpcSendSystemReq, opts ...grpc.CallOption) (*MessageRpcSendSystemResp, error)
	// 发系统消息，与sendsystem区别是消息过多也不会延迟异步处理
	MessageRpcHandleTask(ctx context.Context, in *MessageRpcSendSystemReq, opts ...grpc.CallOption) (*MessageRpcSendSystemResp, error)
	// 发送普通消息
	MessageRpcHandle(ctx context.Context, in *MessageRpcHandleReq, opts ...grpc.CallOption) (*MessageRpcHandleResp, error)
	// 群发消息(医助相关使用 仅支持一次一条消息)
	MessageRpcHandleMulti(ctx context.Context, in *MessageRpcHandleMultiReq, opts ...grpc.CallOption) (*MessageRpcHandleMultiResp, error)
	// 删除某个回话列表
	MessageRpcDelChat(ctx context.Context, in *MessageRpcDelChatReq, opts ...grpc.CallOption) (*MessageDelChatResp, error)
	// 加白名单
	MessageAddToWhiteList(ctx context.Context, in *MessageAddToWhiteListReq, opts ...grpc.CallOption) (*MessageAddToWhiteListResp, error)
	// rpc 消息列表
	MessageRpcListHistory(ctx context.Context, in *MessageRpcListHistoryReq, opts ...grpc.CallOption) (*MessageRpcListHistoryResp, error)
	// rpc 取群聊消息接口，特殊用途。
	MessageRpcGetMessageHistory(ctx context.Context, in *MessageRpcGetMessageHistoryReq, opts ...grpc.CallOption) (*MessageRpcGetMessageHistoryResp, error)
	//
	MessagePushNotifyOnline(ctx context.Context, in *MessagePushNotifyOnlineReq, opts ...grpc.CallOption) (*MessagePushNotifyOnlineResp, error)
	// 发送消息接口
	Send(ctx context.Context, in *SendReq, opts ...grpc.CallOption) (*SendResp, error)
	// 专门发送消息，不做其它逻辑
	MessagePushSend(ctx context.Context, in *MessagePushSendReq, opts ...grpc.CallOption) (*MessagePushSendResp, error)
	// 普通多条消息发送接口
	MessageRpcHandleMulti2(ctx context.Context, in *MessageRpcHandleMulti2Req, opts ...grpc.CallOption) (*MessageRpcHandleMulti2Resp, error)
}

type messageClient struct {
	cc *grpc.ClientConn
}

func NewMessageClient(cc *grpc.ClientConn) MessageClient {
	return &messageClient{cc}
}

func (c *messageClient) Unread(ctx context.Context, in *UnreadReq, opts ...grpc.CallOption) (*UnreadResp, error) {
	out := new(UnreadResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/Unread", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnreadAll(ctx context.Context, in *UnreadAllReq, opts ...grpc.CallOption) (*UnreadAllResp, error) {
	out := new(UnreadAllResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/UnreadAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnreadBatch(ctx context.Context, in *UnreadBatchReq, opts ...grpc.CallOption) (*UnreadBatchResp, error) {
	out := new(UnreadBatchResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/UnreadBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MarkLatestMsgRead(ctx context.Context, in *MarkLatestMsgReadReq, opts ...grpc.CallOption) (*MarkLatestMsgReadResp, error) {
	out := new(MarkLatestMsgReadResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MarkLatestMsgRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnreadSweepV2(ctx context.Context, in *UnreadSweepV2Req, opts ...grpc.CallOption) (*UnreadSweepV2Resp, error) {
	out := new(UnreadSweepV2Resp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/UnreadSweepV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnreadCount(ctx context.Context, in *UnreadCountReq, opts ...grpc.CallOption) (*UnreadCountResp, error) {
	out := new(UnreadCountResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/UnreadCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) ReadMark(ctx context.Context, in *ReadMarkReq, opts ...grpc.CallOption) (*ReadMarkResp, error) {
	out := new(ReadMarkResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/ReadMark", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnreadInfo(ctx context.Context, in *UnreadInfoReq, opts ...grpc.CallOption) (*UnreadInfoResp, error) {
	out := new(UnreadInfoResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/UnreadInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnreadSweep(ctx context.Context, in *UnreadSweepReq, opts ...grpc.CallOption) (*UnreadSweepResp, error) {
	out := new(UnreadSweepResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/unreadSweep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnreadPoint(ctx context.Context, in *UnreadPointReq, opts ...grpc.CallOption) (*UnreadPointResp, error) {
	out := new(UnreadPointResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/unreadPoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) AtUser(ctx context.Context, in *AtUserReq, opts ...grpc.CallOption) (*AtUserResp, error) {
	out := new(AtUserResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/AtUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) ReadAtUser(ctx context.Context, in *ReadAtUserReq, opts ...grpc.CallOption) (*ReadAtUserResp, error) {
	out := new(ReadAtUserResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/readAtUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) FetchMessageAtUser(ctx context.Context, in *FetchMessageAtUserReq, opts ...grpc.CallOption) (*FetchMessageAtUserResp, error) {
	out := new(FetchMessageAtUserResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/FetchMessageAtUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MarkMessageUnRead(ctx context.Context, in *MarkMessageUnReadReq, opts ...grpc.CallOption) (*MarkMessageUnReadResp, error) {
	out := new(MarkMessageUnReadResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MarkMessageUnRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnMarkMessageUnRead(ctx context.Context, in *UnMarkMessageUnReadReq, opts ...grpc.CallOption) (*UnMarkMessageUnReadResp, error) {
	out := new(UnMarkMessageUnReadResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/UnMarkMessageUnRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) FetchMessageUnReadTotal(ctx context.Context, in *FetchMessageUnReadTotalReq, opts ...grpc.CallOption) (*FetchMessageUnReadTotalResp, error) {
	out := new(FetchMessageUnReadTotalResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/FetchMessageUnReadTotal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MarkPrescriptionMessage(ctx context.Context, in *MarkPrescriptionMessageReq, opts ...grpc.CallOption) (*MarkPrescriptionMessageResp, error) {
	out := new(MarkPrescriptionMessageResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MarkPrescriptionMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UnMarkPrescriptionMessage(ctx context.Context, in *UnMarkPrescriptionMessageReq, opts ...grpc.CallOption) (*UnMarkPrescriptionMessageResp, error) {
	out := new(UnMarkPrescriptionMessageResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/UnMarkPrescriptionMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) FetchPrescriptionMessageMark(ctx context.Context, in *FetchPrescriptionMessageMarkReq, opts ...grpc.CallOption) (*FetchPrescriptionMessageMarkResp, error) {
	out := new(FetchPrescriptionMessageMarkResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/FetchPrescriptionMessageMark", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageHandle(ctx context.Context, in *MessageHandleReq, opts ...grpc.CallOption) (*MessageHandleResp, error) {
	out := new(MessageHandleResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageHandle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetPatientChatList(ctx context.Context, in *MessageGetPatientChatListReq, opts ...grpc.CallOption) (*MessageGetPatientChatListResp, error) {
	out := new(MessageGetPatientChatListResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetPatientChatList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetHistory(ctx context.Context, in *MessageGetHistoryReq, opts ...grpc.CallOption) (*MessageGetHistoryResp, error) {
	out := new(MessageGetHistoryResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetSysHistory(ctx context.Context, in *MessageGetSysHistoryReq, opts ...grpc.CallOption) (*MessageGetSysHistoryResp, error) {
	out := new(MessageGetSysHistoryResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetSysHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetOffline(ctx context.Context, in *MessageGetOfflineReq, opts ...grpc.CallOption) (*MessageGetOfflineResp, error) {
	out := new(MessageGetOfflineResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetOffline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetOfflineCount(ctx context.Context, in *MessageGetOfflineCountReq, opts ...grpc.CallOption) (*MessageGetOfflineCountResp, error) {
	out := new(MessageGetOfflineCountResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetOfflineCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetReceipt(ctx context.Context, in *MessageGetReceiptReq, opts ...grpc.CallOption) (*MessageGetReceiptResp, error) {
	out := new(MessageGetReceiptResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetReceipt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetChatlist(ctx context.Context, in *MessageGetChatlistReq, opts ...grpc.CallOption) (*MessageGetChatlistResp, error) {
	out := new(MessageGetChatlistResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetChatlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetLocal(ctx context.Context, in *MessageGetLocalReq, opts ...grpc.CallOption) (*MessageGetLocalResp, error) {
	out := new(MessageGetLocalResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetLocal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageDelChat(ctx context.Context, in *MessageDelChatReq, opts ...grpc.CallOption) (*MessageDelChatResp, error) {
	out := new(MessageDelChatResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageDelChat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageGetImMenu(ctx context.Context, in *MessageGetImMenuReq, opts ...grpc.CallOption) (*MessageGetImMenuResp, error) {
	out := new(MessageGetImMenuResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageGetImMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcSendSystem(ctx context.Context, in *MessageRpcSendSystemReq, opts ...grpc.CallOption) (*MessageRpcSendSystemResp, error) {
	out := new(MessageRpcSendSystemResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcSendSystem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcSendBusinessNotify(ctx context.Context, in *MessageRpcSendSystemReq, opts ...grpc.CallOption) (*MessageRpcSendSystemResp, error) {
	out := new(MessageRpcSendSystemResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcSendBusinessNotify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcHandleTask(ctx context.Context, in *MessageRpcSendSystemReq, opts ...grpc.CallOption) (*MessageRpcSendSystemResp, error) {
	out := new(MessageRpcSendSystemResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcHandleTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcHandle(ctx context.Context, in *MessageRpcHandleReq, opts ...grpc.CallOption) (*MessageRpcHandleResp, error) {
	out := new(MessageRpcHandleResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcHandle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcHandleMulti(ctx context.Context, in *MessageRpcHandleMultiReq, opts ...grpc.CallOption) (*MessageRpcHandleMultiResp, error) {
	out := new(MessageRpcHandleMultiResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcHandleMulti", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcDelChat(ctx context.Context, in *MessageRpcDelChatReq, opts ...grpc.CallOption) (*MessageDelChatResp, error) {
	out := new(MessageDelChatResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcDelChat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageAddToWhiteList(ctx context.Context, in *MessageAddToWhiteListReq, opts ...grpc.CallOption) (*MessageAddToWhiteListResp, error) {
	out := new(MessageAddToWhiteListResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageAddToWhiteList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcListHistory(ctx context.Context, in *MessageRpcListHistoryReq, opts ...grpc.CallOption) (*MessageRpcListHistoryResp, error) {
	out := new(MessageRpcListHistoryResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcListHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcGetMessageHistory(ctx context.Context, in *MessageRpcGetMessageHistoryReq, opts ...grpc.CallOption) (*MessageRpcGetMessageHistoryResp, error) {
	out := new(MessageRpcGetMessageHistoryResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcGetMessageHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessagePushNotifyOnline(ctx context.Context, in *MessagePushNotifyOnlineReq, opts ...grpc.CallOption) (*MessagePushNotifyOnlineResp, error) {
	out := new(MessagePushNotifyOnlineResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessagePushNotifyOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) Send(ctx context.Context, in *SendReq, opts ...grpc.CallOption) (*SendResp, error) {
	out := new(SendResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/Send", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessagePushSend(ctx context.Context, in *MessagePushSendReq, opts ...grpc.CallOption) (*MessagePushSendResp, error) {
	out := new(MessagePushSendResp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessagePushSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MessageRpcHandleMulti2(ctx context.Context, in *MessageRpcHandleMulti2Req, opts ...grpc.CallOption) (*MessageRpcHandleMulti2Resp, error) {
	out := new(MessageRpcHandleMulti2Resp)
	err := c.cc.Invoke(ctx, "/med.xim.v1.Message/MessageRpcHandleMulti2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServer is the server API for Message service.
type MessageServer interface {
	// 获取指定用户指定会话的消息未读数
	Unread(context.Context, *UnreadReq) (*UnreadResp, error)
	// 获取指定用户的所有会话的消息未读数
	UnreadAll(context.Context, *UnreadAllReq) (*UnreadAllResp, error)
	// 批量读取用户指定会话的消息未读数
	UnreadBatch(context.Context, *UnreadBatchReq) (*UnreadBatchResp, error)
	// 标记消息已读
	MarkLatestMsgRead(context.Context, *MarkLatestMsgReadReq) (*MarkLatestMsgReadResp, error)
	// 清除指定会话的消息未读数
	UnreadSweepV2(context.Context, *UnreadSweepV2Req) (*UnreadSweepV2Resp, error)
	// 消息未读数的接口
	UnreadCount(context.Context, *UnreadCountReq) (*UnreadCountResp, error)
	// 标记会话的最新msgId已读
	ReadMark(context.Context, *ReadMarkReq) (*ReadMarkResp, error)
	// 获取会话未读标记
	UnreadInfo(context.Context, *UnreadInfoReq) (*UnreadInfoResp, error)
	//清除指定会话的消息未读数
	UnreadSweep(context.Context, *UnreadSweepReq) (*UnreadSweepResp, error)
	//批量获取未读数
	UnreadPoint(context.Context, *UnreadPointReq) (*UnreadPointResp, error)
	// @me
	AtUser(context.Context, *AtUserReq) (*AtUserResp, error)
	// 读取@me
	ReadAtUser(context.Context, *ReadAtUserReq) (*ReadAtUserResp, error)
	// 批量获取用户@消息
	FetchMessageAtUser(context.Context, *FetchMessageAtUserReq) (*FetchMessageAtUserResp, error)
	// 设置未读消息数（医生|患者 消息）
	MarkMessageUnRead(context.Context, *MarkMessageUnReadReq) (*MarkMessageUnReadResp, error)
	// 取消设置新处方消息
	UnMarkMessageUnRead(context.Context, *UnMarkMessageUnReadReq) (*UnMarkMessageUnReadResp, error)
	// 批量获取用户未读消息数（医生|患者 消息）
	FetchMessageUnReadTotal(context.Context, *FetchMessageUnReadTotalReq) (*FetchMessageUnReadTotalResp, error)
	// 设置新处方消息
	MarkPrescriptionMessage(context.Context, *MarkPrescriptionMessageReq) (*MarkPrescriptionMessageResp, error)
	// 取消设置新处方消息
	UnMarkPrescriptionMessage(context.Context, *UnMarkPrescriptionMessageReq) (*UnMarkPrescriptionMessageResp, error)
	// 批量获取用户处方消息标记
	FetchPrescriptionMessageMark(context.Context, *FetchPrescriptionMessageMarkReq) (*FetchPrescriptionMessageMarkResp, error)
	// 发送消息
	MessageHandle(context.Context, *MessageHandleReq) (*MessageHandleResp, error)
	// 患者端会话列表
	MessageGetPatientChatList(context.Context, *MessageGetPatientChatListReq) (*MessageGetPatientChatListResp, error)
	//消息历史记录
	MessageGetHistory(context.Context, *MessageGetHistoryReq) (*MessageGetHistoryResp, error)
	//系统消息历史记录
	MessageGetSysHistory(context.Context, *MessageGetSysHistoryReq) (*MessageGetSysHistoryResp, error)
	//离线消息
	MessageGetOffline(context.Context, *MessageGetOfflineReq) (*MessageGetOfflineResp, error)
	// 离线消息数量
	MessageGetOfflineCount(context.Context, *MessageGetOfflineCountReq) (*MessageGetOfflineCountResp, error)
	//消息回执
	MessageGetReceipt(context.Context, *MessageGetReceiptReq) (*MessageGetReceiptResp, error)
	//会话列表
	MessageGetChatlist(context.Context, *MessageGetChatlistReq) (*MessageGetChatlistResp, error)
	//本地存储代理
	MessageGetLocal(context.Context, *MessageGetLocalReq) (*MessageGetLocalResp, error)
	//删除会话 批量
	MessageDelChat(context.Context, *MessageDelChatReq) (*MessageDelChatResp, error)
	// 获取动态菜单
	MessageGetImMenu(context.Context, *MessageGetImMenuReq) (*MessageGetImMenuResp, error)
	//jsonrpc
	// 发系统消息
	MessageRpcSendSystem(context.Context, *MessageRpcSendSystemReq) (*MessageRpcSendSystemResp, error)
	// 发送企业通知
	MessageRpcSendBusinessNotify(context.Context, *MessageRpcSendSystemReq) (*MessageRpcSendSystemResp, error)
	// 发系统消息，与sendsystem区别是消息过多也不会延迟异步处理
	MessageRpcHandleTask(context.Context, *MessageRpcSendSystemReq) (*MessageRpcSendSystemResp, error)
	// 发送普通消息
	MessageRpcHandle(context.Context, *MessageRpcHandleReq) (*MessageRpcHandleResp, error)
	// 群发消息(医助相关使用 仅支持一次一条消息)
	MessageRpcHandleMulti(context.Context, *MessageRpcHandleMultiReq) (*MessageRpcHandleMultiResp, error)
	// 删除某个回话列表
	MessageRpcDelChat(context.Context, *MessageRpcDelChatReq) (*MessageDelChatResp, error)
	// 加白名单
	MessageAddToWhiteList(context.Context, *MessageAddToWhiteListReq) (*MessageAddToWhiteListResp, error)
	// rpc 消息列表
	MessageRpcListHistory(context.Context, *MessageRpcListHistoryReq) (*MessageRpcListHistoryResp, error)
	// rpc 取群聊消息接口，特殊用途。
	MessageRpcGetMessageHistory(context.Context, *MessageRpcGetMessageHistoryReq) (*MessageRpcGetMessageHistoryResp, error)
	//
	MessagePushNotifyOnline(context.Context, *MessagePushNotifyOnlineReq) (*MessagePushNotifyOnlineResp, error)
	// 发送消息接口
	Send(context.Context, *SendReq) (*SendResp, error)
	// 专门发送消息，不做其它逻辑
	MessagePushSend(context.Context, *MessagePushSendReq) (*MessagePushSendResp, error)
	// 普通多条消息发送接口
	MessageRpcHandleMulti2(context.Context, *MessageRpcHandleMulti2Req) (*MessageRpcHandleMulti2Resp, error)
}

// UnimplementedMessageServer can be embedded to have forward compatible implementations.
type UnimplementedMessageServer struct {
}

func (*UnimplementedMessageServer) Unread(ctx context.Context, req *UnreadReq) (*UnreadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unread not implemented")
}
func (*UnimplementedMessageServer) UnreadAll(ctx context.Context, req *UnreadAllReq) (*UnreadAllResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadAll not implemented")
}
func (*UnimplementedMessageServer) UnreadBatch(ctx context.Context, req *UnreadBatchReq) (*UnreadBatchResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadBatch not implemented")
}
func (*UnimplementedMessageServer) MarkLatestMsgRead(ctx context.Context, req *MarkLatestMsgReadReq) (*MarkLatestMsgReadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkLatestMsgRead not implemented")
}
func (*UnimplementedMessageServer) UnreadSweepV2(ctx context.Context, req *UnreadSweepV2Req) (*UnreadSweepV2Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadSweepV2 not implemented")
}
func (*UnimplementedMessageServer) UnreadCount(ctx context.Context, req *UnreadCountReq) (*UnreadCountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadCount not implemented")
}
func (*UnimplementedMessageServer) ReadMark(ctx context.Context, req *ReadMarkReq) (*ReadMarkResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadMark not implemented")
}
func (*UnimplementedMessageServer) UnreadInfo(ctx context.Context, req *UnreadInfoReq) (*UnreadInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadInfo not implemented")
}
func (*UnimplementedMessageServer) UnreadSweep(ctx context.Context, req *UnreadSweepReq) (*UnreadSweepResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadSweep not implemented")
}
func (*UnimplementedMessageServer) UnreadPoint(ctx context.Context, req *UnreadPointReq) (*UnreadPointResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadPoint not implemented")
}
func (*UnimplementedMessageServer) AtUser(ctx context.Context, req *AtUserReq) (*AtUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AtUser not implemented")
}
func (*UnimplementedMessageServer) ReadAtUser(ctx context.Context, req *ReadAtUserReq) (*ReadAtUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAtUser not implemented")
}
func (*UnimplementedMessageServer) FetchMessageAtUser(ctx context.Context, req *FetchMessageAtUserReq) (*FetchMessageAtUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchMessageAtUser not implemented")
}
func (*UnimplementedMessageServer) MarkMessageUnRead(ctx context.Context, req *MarkMessageUnReadReq) (*MarkMessageUnReadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkMessageUnRead not implemented")
}
func (*UnimplementedMessageServer) UnMarkMessageUnRead(ctx context.Context, req *UnMarkMessageUnReadReq) (*UnMarkMessageUnReadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnMarkMessageUnRead not implemented")
}
func (*UnimplementedMessageServer) FetchMessageUnReadTotal(ctx context.Context, req *FetchMessageUnReadTotalReq) (*FetchMessageUnReadTotalResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchMessageUnReadTotal not implemented")
}
func (*UnimplementedMessageServer) MarkPrescriptionMessage(ctx context.Context, req *MarkPrescriptionMessageReq) (*MarkPrescriptionMessageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkPrescriptionMessage not implemented")
}
func (*UnimplementedMessageServer) UnMarkPrescriptionMessage(ctx context.Context, req *UnMarkPrescriptionMessageReq) (*UnMarkPrescriptionMessageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnMarkPrescriptionMessage not implemented")
}
func (*UnimplementedMessageServer) FetchPrescriptionMessageMark(ctx context.Context, req *FetchPrescriptionMessageMarkReq) (*FetchPrescriptionMessageMarkResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchPrescriptionMessageMark not implemented")
}
func (*UnimplementedMessageServer) MessageHandle(ctx context.Context, req *MessageHandleReq) (*MessageHandleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageHandle not implemented")
}
func (*UnimplementedMessageServer) MessageGetPatientChatList(ctx context.Context, req *MessageGetPatientChatListReq) (*MessageGetPatientChatListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetPatientChatList not implemented")
}
func (*UnimplementedMessageServer) MessageGetHistory(ctx context.Context, req *MessageGetHistoryReq) (*MessageGetHistoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetHistory not implemented")
}
func (*UnimplementedMessageServer) MessageGetSysHistory(ctx context.Context, req *MessageGetSysHistoryReq) (*MessageGetSysHistoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetSysHistory not implemented")
}
func (*UnimplementedMessageServer) MessageGetOffline(ctx context.Context, req *MessageGetOfflineReq) (*MessageGetOfflineResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetOffline not implemented")
}
func (*UnimplementedMessageServer) MessageGetOfflineCount(ctx context.Context, req *MessageGetOfflineCountReq) (*MessageGetOfflineCountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetOfflineCount not implemented")
}
func (*UnimplementedMessageServer) MessageGetReceipt(ctx context.Context, req *MessageGetReceiptReq) (*MessageGetReceiptResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetReceipt not implemented")
}
func (*UnimplementedMessageServer) MessageGetChatlist(ctx context.Context, req *MessageGetChatlistReq) (*MessageGetChatlistResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetChatlist not implemented")
}
func (*UnimplementedMessageServer) MessageGetLocal(ctx context.Context, req *MessageGetLocalReq) (*MessageGetLocalResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetLocal not implemented")
}
func (*UnimplementedMessageServer) MessageDelChat(ctx context.Context, req *MessageDelChatReq) (*MessageDelChatResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageDelChat not implemented")
}
func (*UnimplementedMessageServer) MessageGetImMenu(ctx context.Context, req *MessageGetImMenuReq) (*MessageGetImMenuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageGetImMenu not implemented")
}
func (*UnimplementedMessageServer) MessageRpcSendSystem(ctx context.Context, req *MessageRpcSendSystemReq) (*MessageRpcSendSystemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcSendSystem not implemented")
}
func (*UnimplementedMessageServer) MessageRpcSendBusinessNotify(ctx context.Context, req *MessageRpcSendSystemReq) (*MessageRpcSendSystemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcSendBusinessNotify not implemented")
}
func (*UnimplementedMessageServer) MessageRpcHandleTask(ctx context.Context, req *MessageRpcSendSystemReq) (*MessageRpcSendSystemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcHandleTask not implemented")
}
func (*UnimplementedMessageServer) MessageRpcHandle(ctx context.Context, req *MessageRpcHandleReq) (*MessageRpcHandleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcHandle not implemented")
}
func (*UnimplementedMessageServer) MessageRpcHandleMulti(ctx context.Context, req *MessageRpcHandleMultiReq) (*MessageRpcHandleMultiResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcHandleMulti not implemented")
}
func (*UnimplementedMessageServer) MessageRpcDelChat(ctx context.Context, req *MessageRpcDelChatReq) (*MessageDelChatResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcDelChat not implemented")
}
func (*UnimplementedMessageServer) MessageAddToWhiteList(ctx context.Context, req *MessageAddToWhiteListReq) (*MessageAddToWhiteListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageAddToWhiteList not implemented")
}
func (*UnimplementedMessageServer) MessageRpcListHistory(ctx context.Context, req *MessageRpcListHistoryReq) (*MessageRpcListHistoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcListHistory not implemented")
}
func (*UnimplementedMessageServer) MessageRpcGetMessageHistory(ctx context.Context, req *MessageRpcGetMessageHistoryReq) (*MessageRpcGetMessageHistoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcGetMessageHistory not implemented")
}
func (*UnimplementedMessageServer) MessagePushNotifyOnline(ctx context.Context, req *MessagePushNotifyOnlineReq) (*MessagePushNotifyOnlineResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessagePushNotifyOnline not implemented")
}
func (*UnimplementedMessageServer) Send(ctx context.Context, req *SendReq) (*SendResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (*UnimplementedMessageServer) MessagePushSend(ctx context.Context, req *MessagePushSendReq) (*MessagePushSendResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessagePushSend not implemented")
}
func (*UnimplementedMessageServer) MessageRpcHandleMulti2(ctx context.Context, req *MessageRpcHandleMulti2Req) (*MessageRpcHandleMulti2Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageRpcHandleMulti2 not implemented")
}

func RegisterMessageServer(s *grpc.Server, srv MessageServer) {
	s.RegisterService(&_Message_serviceDesc, srv)
}

func _Message_Unread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).Unread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/Unread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).Unread(ctx, req.(*UnreadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnreadAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadAllReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnreadAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnreadAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnreadAll(ctx, req.(*UnreadAllReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnreadBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadBatchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnreadBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnreadBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnreadBatch(ctx, req.(*UnreadBatchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MarkLatestMsgRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkLatestMsgReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MarkLatestMsgRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MarkLatestMsgRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MarkLatestMsgRead(ctx, req.(*MarkLatestMsgReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnreadSweepV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadSweepV2Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnreadSweepV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnreadSweepV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnreadSweepV2(ctx, req.(*UnreadSweepV2Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnreadCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnreadCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnreadCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnreadCount(ctx, req.(*UnreadCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_ReadMark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadMarkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ReadMark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/ReadMark",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ReadMark(ctx, req.(*ReadMarkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnreadInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnreadInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnreadInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnreadInfo(ctx, req.(*UnreadInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnreadSweep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadSweepReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnreadSweep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnreadSweep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnreadSweep(ctx, req.(*UnreadSweepReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnreadPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadPointReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnreadPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnreadPoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnreadPoint(ctx, req.(*UnreadPointReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_AtUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AtUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).AtUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/AtUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).AtUser(ctx, req.(*AtUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_ReadAtUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadAtUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ReadAtUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/ReadAtUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ReadAtUser(ctx, req.(*ReadAtUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_FetchMessageAtUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchMessageAtUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).FetchMessageAtUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/FetchMessageAtUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).FetchMessageAtUser(ctx, req.(*FetchMessageAtUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MarkMessageUnRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkMessageUnReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MarkMessageUnRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MarkMessageUnRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MarkMessageUnRead(ctx, req.(*MarkMessageUnReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnMarkMessageUnRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnMarkMessageUnReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnMarkMessageUnRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnMarkMessageUnRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnMarkMessageUnRead(ctx, req.(*UnMarkMessageUnReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_FetchMessageUnReadTotal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchMessageUnReadTotalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).FetchMessageUnReadTotal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/FetchMessageUnReadTotal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).FetchMessageUnReadTotal(ctx, req.(*FetchMessageUnReadTotalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MarkPrescriptionMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkPrescriptionMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MarkPrescriptionMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MarkPrescriptionMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MarkPrescriptionMessage(ctx, req.(*MarkPrescriptionMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UnMarkPrescriptionMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnMarkPrescriptionMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UnMarkPrescriptionMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/UnMarkPrescriptionMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UnMarkPrescriptionMessage(ctx, req.(*UnMarkPrescriptionMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_FetchPrescriptionMessageMark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchPrescriptionMessageMarkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).FetchPrescriptionMessageMark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/FetchPrescriptionMessageMark",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).FetchPrescriptionMessageMark(ctx, req.(*FetchPrescriptionMessageMarkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageHandleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageHandle(ctx, req.(*MessageHandleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetPatientChatList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetPatientChatListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetPatientChatList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetPatientChatList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetPatientChatList(ctx, req.(*MessageGetPatientChatListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetHistory(ctx, req.(*MessageGetHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetSysHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetSysHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetSysHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetSysHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetSysHistory(ctx, req.(*MessageGetSysHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetOffline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetOfflineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetOffline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetOffline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetOffline(ctx, req.(*MessageGetOfflineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetOfflineCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetOfflineCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetOfflineCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetOfflineCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetOfflineCount(ctx, req.(*MessageGetOfflineCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetReceiptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetReceipt(ctx, req.(*MessageGetReceiptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetChatlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetChatlistReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetChatlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetChatlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetChatlist(ctx, req.(*MessageGetChatlistReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetLocal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetLocalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetLocal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetLocal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetLocal(ctx, req.(*MessageGetLocalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageDelChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageDelChatReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageDelChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageDelChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageDelChat(ctx, req.(*MessageDelChatReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageGetImMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageGetImMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageGetImMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageGetImMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageGetImMenu(ctx, req.(*MessageGetImMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcSendSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcSendSystemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcSendSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcSendSystem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcSendSystem(ctx, req.(*MessageRpcSendSystemReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcSendBusinessNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcSendSystemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcSendBusinessNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcSendBusinessNotify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcSendBusinessNotify(ctx, req.(*MessageRpcSendSystemReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcHandleTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcSendSystemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcHandleTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcHandleTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcHandleTask(ctx, req.(*MessageRpcSendSystemReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcHandleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcHandle(ctx, req.(*MessageRpcHandleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcHandleMulti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcHandleMultiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcHandleMulti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcHandleMulti",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcHandleMulti(ctx, req.(*MessageRpcHandleMultiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcDelChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcDelChatReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcDelChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcDelChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcDelChat(ctx, req.(*MessageRpcDelChatReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageAddToWhiteList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageAddToWhiteListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageAddToWhiteList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageAddToWhiteList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageAddToWhiteList(ctx, req.(*MessageAddToWhiteListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcListHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcListHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcListHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcListHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcListHistory(ctx, req.(*MessageRpcListHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcGetMessageHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcGetMessageHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcGetMessageHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcGetMessageHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcGetMessageHistory(ctx, req.(*MessageRpcGetMessageHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessagePushNotifyOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagePushNotifyOnlineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessagePushNotifyOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessagePushNotifyOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessagePushNotifyOnline(ctx, req.(*MessagePushNotifyOnlineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).Send(ctx, req.(*SendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessagePushSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagePushSendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessagePushSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessagePushSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessagePushSend(ctx, req.(*MessagePushSendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MessageRpcHandleMulti2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRpcHandleMulti2Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MessageRpcHandleMulti2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/med.xim.v1.Message/MessageRpcHandleMulti2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MessageRpcHandleMulti2(ctx, req.(*MessageRpcHandleMulti2Req))
	}
	return interceptor(ctx, in, info, handler)
}

var _Message_serviceDesc = grpc.ServiceDesc{
	ServiceName: "med.xim.v1.Message",
	HandlerType: (*MessageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Unread",
			Handler:    _Message_Unread_Handler,
		},
		{
			MethodName: "UnreadAll",
			Handler:    _Message_UnreadAll_Handler,
		},
		{
			MethodName: "UnreadBatch",
			Handler:    _Message_UnreadBatch_Handler,
		},
		{
			MethodName: "MarkLatestMsgRead",
			Handler:    _Message_MarkLatestMsgRead_Handler,
		},
		{
			MethodName: "UnreadSweepV2",
			Handler:    _Message_UnreadSweepV2_Handler,
		},
		{
			MethodName: "UnreadCount",
			Handler:    _Message_UnreadCount_Handler,
		},
		{
			MethodName: "ReadMark",
			Handler:    _Message_ReadMark_Handler,
		},
		{
			MethodName: "UnreadInfo",
			Handler:    _Message_UnreadInfo_Handler,
		},
		{
			MethodName: "unreadSweep",
			Handler:    _Message_UnreadSweep_Handler,
		},
		{
			MethodName: "unreadPoint",
			Handler:    _Message_UnreadPoint_Handler,
		},
		{
			MethodName: "AtUser",
			Handler:    _Message_AtUser_Handler,
		},
		{
			MethodName: "readAtUser",
			Handler:    _Message_ReadAtUser_Handler,
		},
		{
			MethodName: "FetchMessageAtUser",
			Handler:    _Message_FetchMessageAtUser_Handler,
		},
		{
			MethodName: "MarkMessageUnRead",
			Handler:    _Message_MarkMessageUnRead_Handler,
		},
		{
			MethodName: "UnMarkMessageUnRead",
			Handler:    _Message_UnMarkMessageUnRead_Handler,
		},
		{
			MethodName: "FetchMessageUnReadTotal",
			Handler:    _Message_FetchMessageUnReadTotal_Handler,
		},
		{
			MethodName: "MarkPrescriptionMessage",
			Handler:    _Message_MarkPrescriptionMessage_Handler,
		},
		{
			MethodName: "UnMarkPrescriptionMessage",
			Handler:    _Message_UnMarkPrescriptionMessage_Handler,
		},
		{
			MethodName: "FetchPrescriptionMessageMark",
			Handler:    _Message_FetchPrescriptionMessageMark_Handler,
		},
		{
			MethodName: "MessageHandle",
			Handler:    _Message_MessageHandle_Handler,
		},
		{
			MethodName: "MessageGetPatientChatList",
			Handler:    _Message_MessageGetPatientChatList_Handler,
		},
		{
			MethodName: "MessageGetHistory",
			Handler:    _Message_MessageGetHistory_Handler,
		},
		{
			MethodName: "MessageGetSysHistory",
			Handler:    _Message_MessageGetSysHistory_Handler,
		},
		{
			MethodName: "MessageGetOffline",
			Handler:    _Message_MessageGetOffline_Handler,
		},
		{
			MethodName: "MessageGetOfflineCount",
			Handler:    _Message_MessageGetOfflineCount_Handler,
		},
		{
			MethodName: "MessageGetReceipt",
			Handler:    _Message_MessageGetReceipt_Handler,
		},
		{
			MethodName: "MessageGetChatlist",
			Handler:    _Message_MessageGetChatlist_Handler,
		},
		{
			MethodName: "MessageGetLocal",
			Handler:    _Message_MessageGetLocal_Handler,
		},
		{
			MethodName: "MessageDelChat",
			Handler:    _Message_MessageDelChat_Handler,
		},
		{
			MethodName: "MessageGetImMenu",
			Handler:    _Message_MessageGetImMenu_Handler,
		},
		{
			MethodName: "MessageRpcSendSystem",
			Handler:    _Message_MessageRpcSendSystem_Handler,
		},
		{
			MethodName: "MessageRpcSendBusinessNotify",
			Handler:    _Message_MessageRpcSendBusinessNotify_Handler,
		},
		{
			MethodName: "MessageRpcHandleTask",
			Handler:    _Message_MessageRpcHandleTask_Handler,
		},
		{
			MethodName: "MessageRpcHandle",
			Handler:    _Message_MessageRpcHandle_Handler,
		},
		{
			MethodName: "MessageRpcHandleMulti",
			Handler:    _Message_MessageRpcHandleMulti_Handler,
		},
		{
			MethodName: "MessageRpcDelChat",
			Handler:    _Message_MessageRpcDelChat_Handler,
		},
		{
			MethodName: "MessageAddToWhiteList",
			Handler:    _Message_MessageAddToWhiteList_Handler,
		},
		{
			MethodName: "MessageRpcListHistory",
			Handler:    _Message_MessageRpcListHistory_Handler,
		},
		{
			MethodName: "MessageRpcGetMessageHistory",
			Handler:    _Message_MessageRpcGetMessageHistory_Handler,
		},
		{
			MethodName: "MessagePushNotifyOnline",
			Handler:    _Message_MessagePushNotifyOnline_Handler,
		},
		{
			MethodName: "Send",
			Handler:    _Message_Send_Handler,
		},
		{
			MethodName: "MessagePushSend",
			Handler:    _Message_MessagePushSend_Handler,
		},
		{
			MethodName: "MessageRpcHandleMulti2",
			Handler:    _Message_MessageRpcHandleMulti2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "med-common/app/service/med-xim/api/grpc/message.proto",
}

func (m *UnreadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MapId) > 0 {
		i -= len(m.MapId)
		copy(dAtA[i:], m.MapId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnreadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnreadMap) > 0 {
		for k := range m.UnreadMap {
			v := m.UnreadMap[k]
			baseI := i
			i = encodeVarintMessage(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnreadAllReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadAllReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadAllReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *UnreadAllResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadAllResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadAllResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnreadAllMap) > 0 {
		for k := range m.UnreadAllMap {
			v := m.UnreadAllMap[k]
			baseI := i
			i = encodeVarintMessage(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnreadBatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadBatchReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadBatchReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReqStr) > 0 {
		i -= len(m.ReqStr)
		copy(dAtA[i:], m.ReqStr)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ReqStr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnreadBatchResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadBatchResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadBatchResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnreadBatchList) > 0 {
		for iNdEx := len(m.UnreadBatchList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnreadBatchList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnreadBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if len(m.MapId) > 0 {
		i -= len(m.MapId)
		copy(dAtA[i:], m.MapId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapId)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkLatestMsgReadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkLatestMsgReadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkLatestMsgReadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MsgId) > 0 {
		i -= len(m.MsgId)
		copy(dAtA[i:], m.MsgId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MsgId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MapId) > 0 {
		i -= len(m.MapId)
		copy(dAtA[i:], m.MapId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapId)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkLatestMsgReadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkLatestMsgReadResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkLatestMsgReadResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UnreadSweepV2Req) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadSweepV2Req) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadSweepV2Req) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SingleId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SingleId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MapId) > 0 {
		i -= len(m.MapId)
		copy(dAtA[i:], m.MapId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnreadSweepV2Resp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadSweepV2Resp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadSweepV2Resp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UnreadCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadCountReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadCountReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MapIds) > 0 {
		i -= len(m.MapIds)
		copy(dAtA[i:], m.MapIds)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapIds)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnreadCountResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadCountResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadCountResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnreadCountMap) > 0 {
		for k := range m.UnreadCountMap {
			v := m.UnreadCountMap[k]
			baseI := i
			i = encodeVarintMessage(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadMarkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadMarkReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadMarkReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MsgId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x10
	}
	if m.MapId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MapId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadMarkResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadMarkResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadMarkResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UnreadInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MapId) > 0 {
		i -= len(m.MapId)
		copy(dAtA[i:], m.MapId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnreadInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnreadInfoMap) > 0 {
		for k := range m.UnreadInfoMap {
			v := m.UnreadInfoMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintMessage(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnreadMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserPlatform) > 0 {
		i -= len(m.UserPlatform)
		copy(dAtA[i:], m.UserPlatform)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.UserPlatform)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.MsgId) > 0 {
		i -= len(m.MsgId)
		copy(dAtA[i:], m.MsgId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MsgId)))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnreadSweepReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadSweepReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadSweepReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnreadSweepResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadSweepResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadSweepResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnreadPointReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadPointReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadPointReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MapIds) > 0 {
		for iNdEx := len(m.MapIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MapIds[iNdEx])
			copy(dAtA[i:], m.MapIds[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.MapIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Uid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnreadPointResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnreadPointResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnreadPointResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RetMap) > 0 {
		for k := range m.RetMap {
			v := m.RetMap[k]
			baseI := i
			i = encodeVarintMessage(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AtUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtUserReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtUserReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AtUserIds) > 0 {
		dAtA3 := make([]byte, len(m.AtUserIds)*10)
		var j2 int
		for _, num1 := range m.AtUserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintMessage(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x1a
	}
	if m.PatientId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.PatientId))
		i--
		dAtA[i] = 0x10
	}
	if m.DoctorId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.DoctorId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AtUserResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtUserResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtUserResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ReadAtUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadAtUserReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadAtUserReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x18
	}
	if m.OtherUserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OtherUserId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadAtUserResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadAtUserResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadAtUserResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *FetchMessageAtUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMessageAtUserReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchMessageAtUserReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OtherUserIds) > 0 {
		dAtA5 := make([]byte, len(m.OtherUserIds)*10)
		var j4 int
		for _, num1 := range m.OtherUserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintMessage(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchMessageAtUserResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMessageAtUserResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchMessageAtUserResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RetMap) > 0 {
		for k := range m.RetMap {
			v := m.RetMap[k]
			baseI := i
			i = encodeVarintMessage(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintMessage(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MarkMessageUnReadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkMessageUnReadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkMessageUnReadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OtherUserIds) > 0 {
		dAtA7 := make([]byte, len(m.OtherUserIds)*10)
		var j6 int
		for _, num1 := range m.OtherUserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintMessage(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.FromUserRole) > 0 {
		i -= len(m.FromUserRole)
		copy(dAtA[i:], m.FromUserRole)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.FromUserRole)))
		i--
		dAtA[i] = 0x42
	}
	if m.FromUserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.FromUserId))
		i--
		dAtA[i] = 0x38
	}
	if m.MessageId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MessageId))
		i--
		dAtA[i] = 0x30
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x28
	}
	if m.PatientId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.PatientId))
		i--
		dAtA[i] = 0x20
	}
	if m.DoctorId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.DoctorId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HealthmanIds) > 0 {
		dAtA9 := make([]byte, len(m.HealthmanIds)*10)
		var j8 int
		for _, num1 := range m.HealthmanIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintMessage(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x12
	}
	if m.AssistantId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.AssistantId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkMessageUnReadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkMessageUnReadResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkMessageUnReadResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UnMarkMessageUnReadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnMarkMessageUnReadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnMarkMessageUnReadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x18
	}
	if m.OtherUserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OtherUserId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnMarkMessageUnReadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnMarkMessageUnReadResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnMarkMessageUnReadResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *FetchMessageUnReadTotalReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMessageUnReadTotalReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchMessageUnReadTotalReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupIds) > 0 {
		dAtA11 := make([]byte, len(m.GroupIds)*10)
		var j10 int
		for _, num1 := range m.GroupIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintMessage(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OtherUserIds) > 0 {
		dAtA13 := make([]byte, len(m.OtherUserIds)*10)
		var j12 int
		for _, num1 := range m.OtherUserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintMessage(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchMessageUnReadTotalResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMessageUnReadTotalResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchMessageUnReadTotalResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RetMap) > 0 {
		for k := range m.RetMap {
			v := m.RetMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintMessage(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchMessageUnReadTotal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMessageUnReadTotal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchMessageUnReadTotal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AssistantMsgUnreadTotal != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.AssistantMsgUnreadTotal))
		i--
		dAtA[i] = 0x18
	}
	if m.PatientMsgUnreadTotal != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.PatientMsgUnreadTotal))
		i--
		dAtA[i] = 0x10
	}
	if m.DoctorMsgUnreadTotal != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.DoctorMsgUnreadTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkPrescriptionMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkPrescriptionMessageReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkPrescriptionMessageReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FromUserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.FromUserId))
		i--
		dAtA[i] = 0x30
	}
	if m.MessageId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MessageId))
		i--
		dAtA[i] = 0x28
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x20
	}
	if m.PatientId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.PatientId))
		i--
		dAtA[i] = 0x18
	}
	if m.DoctorId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.DoctorId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserIds) > 0 {
		dAtA16 := make([]byte, len(m.UserIds)*10)
		var j15 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintMessage(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkPrescriptionMessageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkPrescriptionMessageResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkPrescriptionMessageResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UnMarkPrescriptionMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnMarkPrescriptionMessageReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnMarkPrescriptionMessageReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x18
	}
	if m.OtherUserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OtherUserId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnMarkPrescriptionMessageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnMarkPrescriptionMessageResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnMarkPrescriptionMessageResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MessageHandleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageHandleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageHandleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.XPlatform) > 0 {
		i -= len(m.XPlatform)
		copy(dAtA[i:], m.XPlatform)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.XPlatform)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SysP) > 0 {
		i -= len(m.SysP)
		copy(dAtA[i:], m.SysP)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.SysP)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CliV) > 0 {
		i -= len(m.CliV)
		copy(dAtA[i:], m.CliV)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.CliV)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageHandleResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageHandleResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageHandleResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Offline) > 0 {
		dAtA18 := make([]byte, len(m.Offline)*10)
		var j17 int
		for _, num1 := range m.Offline {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintMessage(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MsgIdStr) > 0 {
		i -= len(m.MsgIdStr)
		copy(dAtA[i:], m.MsgIdStr)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MsgIdStr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x12
	}
	if m.MsgId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetHistoryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0x52
	}
	if m.Sort != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x48
	}
	if m.Start != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x40
	}
	if m.End != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x38
	}
	if m.Begin != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x30
	}
	if m.Limit != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x20
	}
	if m.HashId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.HashId))
		i--
		dAtA[i] = 0x18
	}
	if m.ToRef != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ToRef))
		i--
		dAtA[i] = 0x10
	}
	if m.ToId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ToId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetHistoryResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.List[iNdEx])
			copy(dAtA[i:], m.List[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.List[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Index != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.More {
		i--
		if m.More {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetSysHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetSysHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetSysHistoryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if m.Start != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x18
	}
	if m.Limit != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.RoleId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RoleId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetSysHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetSysHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetSysHistoryResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.List[iNdEx])
			copy(dAtA[i:], m.List[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.List[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Index != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.More {
		i--
		if m.More {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetOfflineReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetOfflineReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetOfflineReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetOfflineResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetOfflineResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetOfflineResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.List[iNdEx])
			copy(dAtA[i:], m.List[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.List[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetOfflineCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetOfflineCountReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetOfflineCountReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetOfflineCountResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetOfflineCountResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetOfflineCountResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetReceiptReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetReceiptReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetReceiptReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetReceiptResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetReceiptResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetReceiptResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetChatlistReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetChatlistReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetChatlistReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetChatlistResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetChatlistResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetChatlistResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for k := range m.Data {
			v := m.Data[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMessage(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetLocalReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetLocalReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetLocalReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetLocalResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetLocalResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetLocalResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageDelChatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageDelChatReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageDelChatReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MapKeys) > 0 {
		i -= len(m.MapKeys)
		copy(dAtA[i:], m.MapKeys)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapKeys)))
		i--
		dAtA[i] = 0x2a
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x20
	}
	if m.TargetUserRef != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.TargetUserRef))
		i--
		dAtA[i] = 0x18
	}
	if m.TargetUserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.TargetUserId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageDelChatResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageDelChatResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageDelChatResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetPatientChatListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetPatientChatListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetPatientChatListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetPatientChatListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetPatientChatListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetPatientChatListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChatList) > 0 {
		for iNdEx := len(m.ChatList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChatList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetPatientChatList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPatientChatList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPatientChatList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AssistantAvatar) > 0 {
		i -= len(m.AssistantAvatar)
		copy(dAtA[i:], m.AssistantAvatar)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AssistantAvatar)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AssistantName) > 0 {
		i -= len(m.AssistantName)
		copy(dAtA[i:], m.AssistantName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AssistantName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.AssistantId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.AssistantId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DoctorAvatar) > 0 {
		i -= len(m.DoctorAvatar)
		copy(dAtA[i:], m.DoctorAvatar)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DoctorAvatar)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DoctorName) > 0 {
		i -= len(m.DoctorName)
		copy(dAtA[i:], m.DoctorName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DoctorName)))
		i--
		dAtA[i] = 0x22
	}
	if m.DoctorId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.DoctorId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MapId) > 0 {
		i -= len(m.MapId)
		copy(dAtA[i:], m.MapId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetImMenuReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetImMenuReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetImMenuReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CliV) > 0 {
		i -= len(m.CliV)
		copy(dAtA[i:], m.CliV)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.CliV)))
		i--
		dAtA[i] = 0x52
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x48
	}
	if m.PatientId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.PatientId))
		i--
		dAtA[i] = 0x40
	}
	if m.DoctorId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.DoctorId))
		i--
		dAtA[i] = 0x38
	}
	if m.DiseaseTagId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.DiseaseTagId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Mplatform) > 0 {
		i -= len(m.Mplatform)
		copy(dAtA[i:], m.Mplatform)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Mplatform)))
		i--
		dAtA[i] = 0x2a
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x20
	}
	if m.NvVersion != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.NvVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.RnVersion != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RnVersion))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageGetImMenuResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageGetImMenuResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageGetImMenuResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MenuFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MenuFields) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MenuFields) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mplatform) > 0 {
		i -= len(m.Mplatform)
		copy(dAtA[i:], m.Mplatform)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Mplatform)))
		i--
		dAtA[i] = 0x62
	}
	if m.Sort != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x58
	}
	if m.Check != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Check))
		i--
		dAtA[i] = 0x50
	}
	if len(m.JumpUrl) > 0 {
		i -= len(m.JumpUrl)
		copy(dAtA[i:], m.JumpUrl)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.JumpUrl)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x42
	}
	if m.MaxVersion != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MaxVersion))
		i--
		dAtA[i] = 0x38
	}
	if m.MinVersion != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MinVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.JumpType != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.JumpType))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.PkId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.PkId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcSendSystemReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcSendSystemReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcSendSystemReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x32
	}
	if m.Delay {
		i--
		if m.Delay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SenderId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SenderId))
		i--
		dAtA[i] = 0x20
	}
	if m.Cols != nil {
		{
			size, err := m.Cols.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UserIds) > 0 {
		dAtA21 := make([]byte, len(m.UserIds)*10)
		var j20 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintMessage(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendSystemCols) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSystemCols) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendSystemCols) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Extra) > 0 {
		i -= len(m.Extra)
		copy(dAtA[i:], m.Extra)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Extra)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Display != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Display))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Subtitle) > 0 {
		i -= len(m.Subtitle)
		copy(dAtA[i:], m.Subtitle)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Subtitle)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Anchors) > 0 {
		for iNdEx := len(m.Anchors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Anchors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Anchor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Anchor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Anchor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Len != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Href) > 0 {
		i -= len(m.Href)
		copy(dAtA[i:], m.Href)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Href)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcSendSystemResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcSendSystemResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcSendSystemResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcHandleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcHandleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcHandleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsNotNeedRound {
		i--
		if m.IsNotNeedRound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.FromProxy {
		i--
		if m.FromProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcHandleResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcHandleResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcHandleResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GroupId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Offline) > 0 {
		dAtA23 := make([]byte, len(m.Offline)*10)
		var j22 int
		for _, num1 := range m.Offline {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintMessage(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MsgIdStr) > 0 {
		i -= len(m.MsgIdStr)
		copy(dAtA[i:], m.MsgIdStr)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MsgIdStr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x12
	}
	if m.MsgId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcHandleMultiReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcHandleMultiReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcHandleMultiReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ImageUrls) > 0 {
		for iNdEx := len(m.ImageUrls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImageUrls[iNdEx])
			copy(dAtA[i:], m.ImageUrls[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.ImageUrls[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GroupIds) > 0 {
		dAtA25 := make([]byte, len(m.GroupIds)*10)
		var j24 int
		for _, num1 := range m.GroupIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintMessage(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x12
	}
	if m.SendId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SendId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcHandleMultiResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcHandleMultiResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcHandleMultiResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcDelChatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcDelChatReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcDelChatReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MapId) > 0 {
		i -= len(m.MapId)
		copy(dAtA[i:], m.MapId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MapId)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageAddToWhiteListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageAddToWhiteListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageAddToWhiteListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Users[iNdEx])
			copy(dAtA[i:], m.Users[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Users[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessageAddToWhiteListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageAddToWhiteListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageAddToWhiteListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcListHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcListHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcListHistoryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndTime != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x58
	}
	if m.StartTime != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x50
	}
	if m.Sort != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x48
	}
	if m.Limit != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x40
	}
	if m.Start != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x38
	}
	if len(m.HashId) > 0 {
		i -= len(m.HashId)
		copy(dAtA[i:], m.HashId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.HashId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ToRef) > 0 {
		i -= len(m.ToRef)
		copy(dAtA[i:], m.ToRef)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ToRef)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ToId) > 0 {
		i -= len(m.ToId)
		copy(dAtA[i:], m.ToId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ToId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FromRef) > 0 {
		i -= len(m.FromRef)
		copy(dAtA[i:], m.FromRef)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.FromRef)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromId) > 0 {
		i -= len(m.FromId)
		copy(dAtA[i:], m.FromId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.FromId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcListHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcListHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcListHistoryResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.List[iNdEx])
			copy(dAtA[i:], m.List[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.List[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Index != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.More {
		i--
		if m.More {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcGetMessageHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcGetMessageHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcGetMessageHistoryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcGetMessageHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcGetMessageHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcGetMessageHistoryResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.List[iNdEx])
			copy(dAtA[i:], m.List[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.List[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessagePushNotifyOnlineReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessagePushNotifyOnlineReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePushNotifyOnlineReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reference != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Reference))
		i--
		dAtA[i] = 0x10
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessagePushNotifyOnlineResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessagePushNotifyOnlineResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePushNotifyOnlineResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Errcode != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Errcode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Errmsg) > 0 {
		i -= len(m.Errmsg)
		copy(dAtA[i:], m.Errmsg)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Errmsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Data {
		i--
		if m.Data {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchPrescriptionMessageMarkReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchPrescriptionMessageMarkReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchPrescriptionMessageMarkReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupIds) > 0 {
		dAtA28 := make([]byte, len(m.GroupIds)*10)
		var j27 int
		for _, num1 := range m.GroupIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintMessage(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OtherUserIds) > 0 {
		dAtA30 := make([]byte, len(m.OtherUserIds)*10)
		var j29 int
		for _, num1 := range m.OtherUserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintMessage(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchPrescriptionMessageMarkResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchPrescriptionMessageMarkResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchPrescriptionMessageMarkResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RetMap) > 0 {
		for k := range m.RetMap {
			v := m.RetMap[k]
			baseI := i
			i = encodeVarintMessage(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintMessage(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedPush {
		i--
		if m.NeedPush {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsSave {
		i--
		if m.IsSave {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ToUsers) > 0 {
		for iNdEx := len(m.ToUsers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToUsers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SucceedUids) > 0 {
		dAtA33 := make([]byte, len(m.SucceedUids)*10)
		var j32 int
		for _, num1 := range m.SucceedUids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintMessage(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessagePushSendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessagePushSendReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePushSendReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedSave {
		i--
		if m.NeedSave {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ToUserStr) > 0 {
		i -= len(m.ToUserStr)
		copy(dAtA[i:], m.ToUserStr)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ToUserStr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MsgStr) > 0 {
		i -= len(m.MsgStr)
		copy(dAtA[i:], m.MsgStr)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MsgStr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessagePushSendResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessagePushSendResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePushSendResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcHandleMulti2Req) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcHandleMulti2Req) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcHandleMulti2Req) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReqList) > 0 {
		for iNdEx := len(m.ReqList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReqList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessageRpcHandleMulti2Resp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRpcHandleMulti2Resp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageRpcHandleMulti2Resp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UnreadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MapId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UnreadMap) > 0 {
		for k, v := range m.UnreadMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + sovMessage(uint64(v))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadAllReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadAllResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UnreadAllMap) > 0 {
		for k, v := range m.UnreadAllMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + sovMessage(uint64(v))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadBatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReqStr)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadBatchResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UnreadBatchList) > 0 {
		for _, e := range m.UnreadBatchList {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	l = len(m.MapId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovMessage(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkLatestMsgReadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	l = len(m.MapId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.MsgId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkLatestMsgReadResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadSweepV2Req) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MapId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.SingleId != 0 {
		n += 1 + sovMessage(uint64(m.SingleId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadSweepV2Resp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MapIds)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadCountResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UnreadCountMap) > 0 {
		for k, v := range m.UnreadCountMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + sovMessage(uint64(v))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadMarkReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapId != 0 {
		n += 1 + sovMessage(uint64(m.MapId))
	}
	if m.MsgId != 0 {
		n += 1 + sovMessage(uint64(m.MsgId))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadMarkResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MapId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UnreadInfoMap) > 0 {
		for k, v := range m.UnreadInfoMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + sovMessage(uint64(k)) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	l = len(m.MsgId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	l = len(m.UserPlatform)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadSweepReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMessage(uint64(m.Uid))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadSweepResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMessage(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadPointReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMessage(uint64(m.Uid))
	}
	if len(m.MapIds) > 0 {
		for _, s := range m.MapIds {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnreadPointResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RetMap) > 0 {
		for k, v := range m.RetMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + sovMessage(uint64(v))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AtUserReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoctorId != 0 {
		n += 1 + sovMessage(uint64(m.DoctorId))
	}
	if m.PatientId != 0 {
		n += 1 + sovMessage(uint64(m.PatientId))
	}
	if len(m.AtUserIds) > 0 {
		l = 0
		for _, e := range m.AtUserIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AtUserResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadAtUserReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.OtherUserId != 0 {
		n += 1 + sovMessage(uint64(m.OtherUserId))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadAtUserResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchMessageAtUserReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMessage(uint64(m.Uid))
	}
	if len(m.OtherUserIds) > 0 {
		l = 0
		for _, e := range m.OtherUserIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchMessageAtUserResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RetMap) > 0 {
		for k, v := range m.RetMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMessage(uint64(k)) + 1 + sovMessage(uint64(v))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkMessageUnReadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssistantId != 0 {
		n += 1 + sovMessage(uint64(m.AssistantId))
	}
	if len(m.HealthmanIds) > 0 {
		l = 0
		for _, e := range m.HealthmanIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.DoctorId != 0 {
		n += 1 + sovMessage(uint64(m.DoctorId))
	}
	if m.PatientId != 0 {
		n += 1 + sovMessage(uint64(m.PatientId))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.MessageId != 0 {
		n += 1 + sovMessage(uint64(m.MessageId))
	}
	if m.FromUserId != 0 {
		n += 1 + sovMessage(uint64(m.FromUserId))
	}
	l = len(m.FromUserRole)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.OtherUserIds) > 0 {
		l = 0
		for _, e := range m.OtherUserIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkMessageUnReadResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnMarkMessageUnReadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.OtherUserId != 0 {
		n += 1 + sovMessage(uint64(m.OtherUserId))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnMarkMessageUnReadResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchMessageUnReadTotalReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if len(m.OtherUserIds) > 0 {
		l = 0
		for _, e := range m.OtherUserIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if len(m.GroupIds) > 0 {
		l = 0
		for _, e := range m.GroupIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchMessageUnReadTotalResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RetMap) > 0 {
		for k, v := range m.RetMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + sovMessage(uint64(k)) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchMessageUnReadTotal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoctorMsgUnreadTotal != 0 {
		n += 1 + sovMessage(uint64(m.DoctorMsgUnreadTotal))
	}
	if m.PatientMsgUnreadTotal != 0 {
		n += 1 + sovMessage(uint64(m.PatientMsgUnreadTotal))
	}
	if m.AssistantMsgUnreadTotal != 0 {
		n += 1 + sovMessage(uint64(m.AssistantMsgUnreadTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkPrescriptionMessageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.DoctorId != 0 {
		n += 1 + sovMessage(uint64(m.DoctorId))
	}
	if m.PatientId != 0 {
		n += 1 + sovMessage(uint64(m.PatientId))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.MessageId != 0 {
		n += 1 + sovMessage(uint64(m.MessageId))
	}
	if m.FromUserId != 0 {
		n += 1 + sovMessage(uint64(m.FromUserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkPrescriptionMessageResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnMarkPrescriptionMessageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.OtherUserId != 0 {
		n += 1 + sovMessage(uint64(m.OtherUserId))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnMarkPrescriptionMessageResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageHandleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CliV)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.SysP)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.XPlatform)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageHandleResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgId != 0 {
		n += 1 + sovMessage(uint64(m.MsgId))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.MsgIdStr)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Offline) > 0 {
		l = 0
		for _, e := range m.Offline {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetHistoryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToId != 0 {
		n += 1 + sovMessage(uint64(m.ToId))
	}
	if m.ToRef != 0 {
		n += 1 + sovMessage(uint64(m.ToRef))
	}
	if m.HashId != 0 {
		n += 1 + sovMessage(uint64(m.HashId))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.Limit != 0 {
		n += 1 + sovMessage(uint64(m.Limit))
	}
	if m.Begin != 0 {
		n += 1 + sovMessage(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovMessage(uint64(m.End))
	}
	if m.Start != 0 {
		n += 1 + sovMessage(uint64(m.Start))
	}
	if m.Sort != 0 {
		n += 1 + sovMessage(uint64(m.Sort))
	}
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetHistoryResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMessage(uint64(m.Start))
	}
	if m.More {
		n += 2
	}
	if m.Index != 0 {
		n += 1 + sovMessage(uint64(m.Index))
	}
	if len(m.List) > 0 {
		for _, s := range m.List {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetSysHistoryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleId != 0 {
		n += 1 + sovMessage(uint64(m.RoleId))
	}
	if m.Limit != 0 {
		n += 1 + sovMessage(uint64(m.Limit))
	}
	if m.Start != 0 {
		n += 1 + sovMessage(uint64(m.Start))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetSysHistoryResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMessage(uint64(m.Start))
	}
	if m.More {
		n += 2
	}
	if m.Index != 0 {
		n += 1 + sovMessage(uint64(m.Index))
	}
	if len(m.List) > 0 {
		for _, s := range m.List {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetOfflineReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetOfflineResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, s := range m.List {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetOfflineCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetOfflineCountResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovMessage(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetReceiptReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMessage(uint64(m.Id))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetReceiptResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetChatlistReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetChatlistResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + len(v) + sovMessage(uint64(len(v)))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetLocalReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetLocalResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageDelChatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.TargetUserId != 0 {
		n += 1 + sovMessage(uint64(m.TargetUserId))
	}
	if m.TargetUserRef != 0 {
		n += 1 + sovMessage(uint64(m.TargetUserRef))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	l = len(m.MapKeys)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageDelChatResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetPatientChatListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetPatientChatListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChatList) > 0 {
		for _, e := range m.ChatList {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPatientChatList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MapId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.DoctorId != 0 {
		n += 1 + sovMessage(uint64(m.DoctorId))
	}
	l = len(m.DoctorName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.DoctorAvatar)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.AssistantId != 0 {
		n += 1 + sovMessage(uint64(m.AssistantId))
	}
	l = len(m.AssistantName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AssistantAvatar)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetImMenuReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	if m.RnVersion != 0 {
		n += 1 + sovMessage(uint64(m.RnVersion))
	}
	if m.NvVersion != 0 {
		n += 1 + sovMessage(uint64(m.NvVersion))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	l = len(m.Mplatform)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.DiseaseTagId != 0 {
		n += 1 + sovMessage(uint64(m.DiseaseTagId))
	}
	if m.DoctorId != 0 {
		n += 1 + sovMessage(uint64(m.DoctorId))
	}
	if m.PatientId != 0 {
		n += 1 + sovMessage(uint64(m.PatientId))
	}
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	l = len(m.CliV)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageGetImMenuResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MenuFields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PkId != 0 {
		n += 1 + sovMessage(uint64(m.PkId))
	}
	if m.Id != 0 {
		n += 1 + sovMessage(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	if m.JumpType != 0 {
		n += 1 + sovMessage(uint64(m.JumpType))
	}
	if m.MinVersion != 0 {
		n += 1 + sovMessage(uint64(m.MinVersion))
	}
	if m.MaxVersion != 0 {
		n += 1 + sovMessage(uint64(m.MaxVersion))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.JumpUrl)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Check != 0 {
		n += 1 + sovMessage(uint64(m.Check))
	}
	if m.Sort != 0 {
		n += 1 + sovMessage(uint64(m.Sort))
	}
	l = len(m.Mplatform)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcSendSystemReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.Cols != nil {
		l = m.Cols.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.SenderId != 0 {
		n += 1 + sovMessage(uint64(m.SenderId))
	}
	if m.Delay {
		n += 2
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendSystemCols) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Anchors) > 0 {
		for _, e := range m.Anchors {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Subtitle)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Display != 0 {
		n += 1 + sovMessage(uint64(m.Display))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Anchor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Href)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovMessage(uint64(m.Start))
	}
	if m.Len != 0 {
		n += 1 + sovMessage(uint64(m.Len))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcSendSystemResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcHandleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.FromProxy {
		n += 2
	}
	if m.IsNotNeedRound {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcHandleResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgId != 0 {
		n += 1 + sovMessage(uint64(m.MsgId))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.MsgIdStr)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Offline) > 0 {
		l = 0
		for _, e := range m.Offline {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.GroupId != 0 {
		n += 1 + sovMessage(uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcHandleMultiReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendId != 0 {
		n += 1 + sovMessage(uint64(m.SendId))
	}
	if len(m.GroupIds) > 0 {
		l = 0
		for _, e := range m.GroupIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if len(m.ImageUrls) > 0 {
		for _, s := range m.ImageUrls {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcHandleMultiResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcDelChatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	l = len(m.MapId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageAddToWhiteListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, s := range m.Users {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageAddToWhiteListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcListHistoryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.FromRef)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ToId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ToRef)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.HashId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovMessage(uint64(m.Start))
	}
	if m.Limit != 0 {
		n += 1 + sovMessage(uint64(m.Limit))
	}
	if m.Sort != 0 {
		n += 1 + sovMessage(uint64(m.Sort))
	}
	if m.StartTime != 0 {
		n += 1 + sovMessage(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovMessage(uint64(m.EndTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcListHistoryResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMessage(uint64(m.Start))
	}
	if m.More {
		n += 2
	}
	if m.Index != 0 {
		n += 1 + sovMessage(uint64(m.Index))
	}
	if len(m.List) > 0 {
		for _, s := range m.List {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcGetMessageHistoryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcGetMessageHistoryResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, s := range m.List {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessagePushNotifyOnlineReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Reference != 0 {
		n += 1 + sovMessage(uint64(m.Reference))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessagePushNotifyOnlineResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data {
		n += 2
	}
	l = len(m.Errmsg)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Errcode != 0 {
		n += 1 + sovMessage(uint64(m.Errcode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchPrescriptionMessageMarkReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessage(uint64(m.UserId))
	}
	if len(m.OtherUserIds) > 0 {
		l = 0
		for _, e := range m.OtherUserIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if len(m.GroupIds) > 0 {
		l = 0
		for _, e := range m.GroupIds {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchPrescriptionMessageMarkResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RetMap) > 0 {
		for k, v := range m.RetMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMessage(uint64(k)) + 1 + sovMessage(uint64(v))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.ToUsers) > 0 {
		for _, e := range m.ToUsers {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.IsSave {
		n += 2
	}
	if m.NeedPush {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SucceedUids) > 0 {
		l = 0
		for _, e := range m.SucceedUids {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessagePushSendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MsgStr)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ToUserStr)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.NeedSave {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessagePushSendResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcHandleMulti2Req) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReqList) > 0 {
		for _, e := range m.ReqList {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageRpcHandleMulti2Resp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UnreadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnreadMap == nil {
				m.UnreadMap = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UnreadMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadAllReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadAllReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadAllReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadAllResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadAllResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadAllResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadAllMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnreadAllMap == nil {
				m.UnreadAllMap = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UnreadAllMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadBatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadBatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadBatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadBatchResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadBatchResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadBatchResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadBatchList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnreadBatchList = append(m.UnreadBatchList, &UnreadBatch{})
			if err := m.UnreadBatchList[len(m.UnreadBatchList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkLatestMsgReadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkLatestMsgReadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkLatestMsgReadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkLatestMsgReadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkLatestMsgReadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkLatestMsgReadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadSweepV2Req) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadSweepV2Req: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadSweepV2Req: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleId", wireType)
			}
			m.SingleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SingleId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadSweepV2Resp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadSweepV2Resp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadSweepV2Resp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapIds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadCountResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadCountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadCountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadCountMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnreadCountMap == nil {
				m.UnreadCountMap = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UnreadCountMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadMarkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadMarkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadMarkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			m.MapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadMarkResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadMarkResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadMarkResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadInfoMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnreadInfoMap == nil {
				m.UnreadInfoMap = make(map[uint32]*UnreadMark)
			}
			var mapkey uint32
			var mapvalue *UnreadMark
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UnreadMark{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UnreadInfoMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadMark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadMark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPlatform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPlatform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadSweepReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadSweepReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadSweepReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadSweepResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadSweepResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadSweepResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadPointReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadPointReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadPointReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapIds = append(m.MapIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnreadPointResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnreadPointResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnreadPointResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetMap == nil {
				m.RetMap = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RetMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			m.DoctorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoctorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientId", wireType)
			}
			m.PatientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatientId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtUserIds = append(m.AtUserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AtUserIds) == 0 {
					m.AtUserIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtUserIds = append(m.AtUserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtUserIds", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtUserResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadAtUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadAtUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadAtUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherUserId", wireType)
			}
			m.OtherUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherUserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadAtUserResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadAtUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadAtUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMessageAtUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchMessageAtUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchMessageAtUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OtherUserIds = append(m.OtherUserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OtherUserIds) == 0 {
					m.OtherUserIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OtherUserIds = append(m.OtherUserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherUserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMessageAtUserResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchMessageAtUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchMessageAtUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetMap == nil {
				m.RetMap = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RetMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkMessageUnReadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkMessageUnReadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkMessageUnReadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistantId", wireType)
			}
			m.AssistantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssistantId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HealthmanIds = append(m.HealthmanIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.HealthmanIds) == 0 {
					m.HealthmanIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HealthmanIds = append(m.HealthmanIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthmanIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			m.DoctorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoctorId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientId", wireType)
			}
			m.PatientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUserId", wireType)
			}
			m.FromUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUserRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromUserRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OtherUserIds = append(m.OtherUserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OtherUserIds) == 0 {
					m.OtherUserIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OtherUserIds = append(m.OtherUserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherUserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkMessageUnReadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkMessageUnReadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkMessageUnReadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnMarkMessageUnReadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnMarkMessageUnReadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnMarkMessageUnReadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherUserId", wireType)
			}
			m.OtherUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnMarkMessageUnReadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnMarkMessageUnReadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnMarkMessageUnReadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMessageUnReadTotalReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchMessageUnReadTotalReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchMessageUnReadTotalReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OtherUserIds = append(m.OtherUserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OtherUserIds) == 0 {
					m.OtherUserIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OtherUserIds = append(m.OtherUserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherUserIds", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupIds = append(m.GroupIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupIds) == 0 {
					m.GroupIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupIds = append(m.GroupIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMessageUnReadTotalResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchMessageUnReadTotalResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchMessageUnReadTotalResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetMap == nil {
				m.RetMap = make(map[int64]*FetchMessageUnReadTotal)
			}
			var mapkey int64
			var mapvalue *FetchMessageUnReadTotal
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FetchMessageUnReadTotal{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RetMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMessageUnReadTotal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchMessageUnReadTotal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchMessageUnReadTotal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorMsgUnreadTotal", wireType)
			}
			m.DoctorMsgUnreadTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoctorMsgUnreadTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientMsgUnreadTotal", wireType)
			}
			m.PatientMsgUnreadTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatientMsgUnreadTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistantMsgUnreadTotal", wireType)
			}
			m.AssistantMsgUnreadTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssistantMsgUnreadTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkPrescriptionMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkPrescriptionMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkPrescriptionMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIds) == 0 {
					m.UserIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			m.DoctorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoctorId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientId", wireType)
			}
			m.PatientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatientId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUserId", wireType)
			}
			m.FromUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkPrescriptionMessageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkPrescriptionMessageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkPrescriptionMessageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnMarkPrescriptionMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnMarkPrescriptionMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnMarkPrescriptionMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherUserId", wireType)
			}
			m.OtherUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnMarkPrescriptionMessageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnMarkPrescriptionMessageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnMarkPrescriptionMessageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageHandleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageHandleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageHandleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CliV", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CliV = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XPlatform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XPlatform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageHandleResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageHandleResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageHandleResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIdStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgIdStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Offline = append(m.Offline, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Offline) == 0 {
					m.Offline = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Offline = append(m.Offline, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Offline", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToId", wireType)
			}
			m.ToId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRef", wireType)
			}
			m.ToRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToRef |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashId", wireType)
			}
			m.HashId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field More", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.More = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetSysHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetSysHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetSysHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			m.RoleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoleId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetSysHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetSysHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetSysHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field More", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.More = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetOfflineReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetOfflineReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetOfflineReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetOfflineResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetOfflineResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetOfflineResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetOfflineCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetOfflineCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetOfflineCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetOfflineCountResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetOfflineCountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetOfflineCountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetReceiptReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetReceiptReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetReceiptReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetReceiptResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetReceiptResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetReceiptResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetChatlistReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetChatlistReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetChatlistReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetChatlistResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetChatlistResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetChatlistResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetLocalReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetLocalReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetLocalReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetLocalResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetLocalResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetLocalResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageDelChatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageDelChatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageDelChatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUserId", wireType)
			}
			m.TargetUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetUserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUserRef", wireType)
			}
			m.TargetUserRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetUserRef |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapKeys = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageDelChatResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageDelChatResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageDelChatResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetPatientChatListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetPatientChatListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetPatientChatListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetPatientChatListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetPatientChatListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetPatientChatListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatList = append(m.ChatList, &GetPatientChatList{})
			if err := m.ChatList[len(m.ChatList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPatientChatList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPatientChatList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPatientChatList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			m.DoctorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoctorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorAvatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoctorAvatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistantId", wireType)
			}
			m.AssistantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssistantId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistantName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssistantName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistantAvatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssistantAvatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetImMenuReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetImMenuReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetImMenuReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RnVersion", wireType)
			}
			m.RnVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RnVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NvVersion", wireType)
			}
			m.NvVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NvVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mplatform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mplatform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiseaseTagId", wireType)
			}
			m.DiseaseTagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiseaseTagId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoctorId", wireType)
			}
			m.DoctorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoctorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatientId", wireType)
			}
			m.PatientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatientId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CliV", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CliV = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageGetImMenuResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageGetImMenuResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageGetImMenuResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &MenuFields{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MenuFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MenuFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MenuFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkId", wireType)
			}
			m.PkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpType", wireType)
			}
			m.JumpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JumpType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVersion", wireType)
			}
			m.MinVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVersion", wireType)
			}
			m.MaxVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			m.Check = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Check |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mplatform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mplatform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcSendSystemReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcSendSystemReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcSendSystemReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIds) == 0 {
					m.UserIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cols == nil {
				m.Cols = &SendSystemCols{}
			}
			if err := m.Cols.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderId", wireType)
			}
			m.SenderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Delay = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendSystemCols) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendSystemCols: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendSystemCols: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Anchors = append(m.Anchors, &Anchor{})
			if err := m.Anchors[len(m.Anchors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			m.Display = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Display |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Anchor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Anchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Anchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Href", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Href = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcSendSystemResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcSendSystemResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcSendSystemResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcHandleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcHandleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcHandleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FromProxy = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNotNeedRound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNotNeedRound = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcHandleResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcHandleResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcHandleResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIdStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgIdStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Offline = append(m.Offline, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Offline) == 0 {
					m.Offline = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Offline = append(m.Offline, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Offline", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcHandleMultiReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcHandleMultiReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcHandleMultiReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendId", wireType)
			}
			m.SendId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupIds = append(m.GroupIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupIds) == 0 {
					m.GroupIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupIds = append(m.GroupIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIds", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrls = append(m.ImageUrls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcHandleMultiResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcHandleMultiResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcHandleMultiResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcDelChatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcDelChatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcDelChatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageAddToWhiteListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageAddToWhiteListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageAddToWhiteListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageAddToWhiteListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageAddToWhiteListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageAddToWhiteListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcListHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcListHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcListHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcListHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcListHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcListHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field More", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.More = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcGetMessageHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcGetMessageHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcGetMessageHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcGetMessageHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcGetMessageHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcGetMessageHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessagePushNotifyOnlineReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessagePushNotifyOnlineReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessagePushNotifyOnlineReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &SendSystemCols{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			m.Reference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reference |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessagePushNotifyOnlineResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessagePushNotifyOnlineResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessagePushNotifyOnlineResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Data = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errmsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errmsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errcode", wireType)
			}
			m.Errcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errcode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchPrescriptionMessageMarkReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchPrescriptionMessageMarkReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchPrescriptionMessageMarkReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OtherUserIds = append(m.OtherUserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OtherUserIds) == 0 {
					m.OtherUserIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OtherUserIds = append(m.OtherUserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherUserIds", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupIds = append(m.GroupIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupIds) == 0 {
					m.GroupIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupIds = append(m.GroupIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchPrescriptionMessageMarkResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchPrescriptionMessageMarkResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchPrescriptionMessageMarkResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetMap == nil {
				m.RetMap = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RetMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &entity.Message{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUsers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToUsers = append(m.ToUsers, &misc.User{})
			if err := m.ToUsers[len(m.ToUsers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSave", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSave = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedPush", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedPush = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SucceedUids = append(m.SucceedUids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SucceedUids) == 0 {
					m.SucceedUids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SucceedUids = append(m.SucceedUids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SucceedUids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessagePushSendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessagePushSendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessagePushSendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUserStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToUserStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedSave", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedSave = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessagePushSendResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessagePushSendResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessagePushSendResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcHandleMulti2Req) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcHandleMulti2Req: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcHandleMulti2Req: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqList = append(m.ReqList, &MessageRpcHandleReq{})
			if err := m.ReqList[len(m.ReqList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRpcHandleMulti2Resp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRpcHandleMulti2Resp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRpcHandleMulti2Resp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
